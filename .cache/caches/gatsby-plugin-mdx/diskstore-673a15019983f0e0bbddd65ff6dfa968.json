{"expireTime":9007200872306494000,"key":"gatsby-plugin-mdx-entire-payload-d1a16cc33b88bef104e3182f0d28565c-","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"In this guide we will create a web interface that consumes and displays data from the Kwikswap Subgraph. The goal is to provide a quick overview of a setup that you can extend to create your own UIs and analytics around Kwikswap data.","position":{"start":{"line":2,"column":1,"offset":2},"end":{"line":2,"column":235,"offset":236},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":2},"end":{"line":2,"column":235,"offset":236},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Many different libraries can be used to create an interface and a connection to the subgraph graphql endpoint, but in this guide we will use ","position":{"start":{"line":4,"column":1,"offset":240},"end":{"line":4,"column":142,"offset":381},"indent":[]}},{"type":"link","title":null,"url":"https://reactjs.org/","children":[{"type":"text","value":"React","position":{"start":{"line":4,"column":143,"offset":382},"end":{"line":4,"column":148,"offset":387},"indent":[]}}],"position":{"start":{"line":4,"column":142,"offset":381},"end":{"line":4,"column":171,"offset":410},"indent":[]}},{"type":"text","value":" for the interface, and ","position":{"start":{"line":4,"column":171,"offset":410},"end":{"line":4,"column":195,"offset":434},"indent":[]}},{"type":"link","title":null,"url":"https://www.apollographql.com/docs/react/","children":[{"type":"text","value":"Apollo Client","position":{"start":{"line":4,"column":196,"offset":435},"end":{"line":4,"column":209,"offset":448},"indent":[]}}],"position":{"start":{"line":4,"column":195,"offset":434},"end":{"line":4,"column":253,"offset":492},"indent":[]}},{"type":"text","value":" for sending queries. We'll also be using yarn for dependency management.","position":{"start":{"line":4,"column":253,"offset":492},"end":{"line":4,"column":326,"offset":565},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":240},"end":{"line":4,"column":326,"offset":565},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Setup and Installs","position":{"start":{"line":6,"column":5,"offset":573},"end":{"line":6,"column":23,"offset":591},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":569},"end":{"line":6,"column":23,"offset":591},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"We'll need to create the basic skeleton for the application. We'll use ","position":{"start":{"line":8,"column":1,"offset":595},"end":{"line":8,"column":72,"offset":666},"indent":[]}},{"type":"link","title":null,"url":"https://reactjs.org/docs/create-a-new-react-app.html","children":[{"type":"text","value":"create-react-app","position":{"start":{"line":8,"column":73,"offset":667},"end":{"line":8,"column":89,"offset":683},"indent":[]}}],"position":{"start":{"line":8,"column":72,"offset":666},"end":{"line":8,"column":144,"offset":738},"indent":[]}},{"type":"text","value":" for this. We'll also add the dependencies we need. Navigate to your root location in your command line and run:","position":{"start":{"line":8,"column":144,"offset":738},"end":{"line":8,"column":256,"offset":850},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":595},"end":{"line":8,"column":256,"offset":850},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"yarn create react-app kwikswap-demo\ncd kwikswap-demo\nyarn add  apollo-client apollo-cache-inmemory apollo-link-http graphql graphql-tag @apollo/react-hooks\nyarn start","position":{"start":{"line":10,"column":1,"offset":854},"end":{"line":15,"column":4,"offset":1043},"indent":[1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"In your browser you should see the default React app running. In a text editor open ","position":{"start":{"line":17,"column":1,"offset":1047},"end":{"line":17,"column":85,"offset":1131},"indent":[]}},{"type":"inlineCode","value":"App.js","position":{"start":{"line":17,"column":85,"offset":1131},"end":{"line":17,"column":93,"offset":1139},"indent":[]}},{"type":"text","value":" within ","position":{"start":{"line":17,"column":93,"offset":1139},"end":{"line":17,"column":101,"offset":1147},"indent":[]}},{"type":"inlineCode","value":"src","position":{"start":{"line":17,"column":101,"offset":1147},"end":{"line":17,"column":106,"offset":1152},"indent":[]}},{"type":"text","value":" and replace the contents with this stripped down boilerplate. We'll add to this as we go.","position":{"start":{"line":17,"column":106,"offset":1152},"end":{"line":17,"column":196,"offset":1242},"indent":[]}}],"position":{"start":{"line":17,"column":1,"offset":1047},"end":{"line":17,"column":196,"offset":1242},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"import React from 'react'\nimport './App.css'\n\nfunction App() {\n  return <div></div>\n}\n\nexport default App","position":{"start":{"line":19,"column":1,"offset":1246},"end":{"line":28,"column":4,"offset":1378},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Graphql Client","position":{"start":{"line":30,"column":5,"offset":1386},"end":{"line":30,"column":19,"offset":1400},"indent":[]}}],"position":{"start":{"line":30,"column":1,"offset":1382},"end":{"line":30,"column":19,"offset":1400},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"We need to set up some middleware in order to make requests to the Kwikswap subgraph and receive data. To do this we'll use Apollo and create a graphql client to handle this.","position":{"start":{"line":32,"column":1,"offset":1404},"end":{"line":32,"column":175,"offset":1578},"indent":[]}}],"position":{"start":{"line":32,"column":1,"offset":1404},"end":{"line":32,"column":175,"offset":1578},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Add the imports shown below and instantiate a new client instance. Notice how we use the link to the Kwikswap subgraph here.","position":{"start":{"line":34,"column":4,"offset":1585},"end":{"line":34,"column":128,"offset":1709},"indent":[]}}],"position":{"start":{"line":34,"column":4,"offset":1585},"end":{"line":34,"column":128,"offset":1709},"indent":[]}}],"position":{"start":{"line":34,"column":1,"offset":1582},"end":{"line":34,"column":128,"offset":1709},"indent":[]}}],"position":{"start":{"line":34,"column":1,"offset":1582},"end":{"line":34,"column":128,"offset":1709},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"import React from \"react\"\nimport \"./App.css\"\nimport { ApolloClient } from \"apollo-client\"\nimport { InMemoryCache } from \"apollo-cache-inmemory\"\nimport { HttpLink } from \"apollo-link-http\"\n\nexport const client = new ApolloClient({\n link: new HttpLink({\n   uri: \"https://thegraph.com/explorer/subgraph/kwikswap/kwikswap-subgraph\"\n }),\n cache: new InMemoryCache(),\n})\n\nfunction App() {\n return <div></div>\n}\n\nexport default App\n","position":{"start":{"line":36,"column":1,"offset":1713},"end":{"line":56,"column":4,"offset":2176},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"list","ordered":true,"start":2,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"We also need to add a context so that Apollo can handle requests properly. In your ","position":{"start":{"line":58,"column":4,"offset":2183},"end":{"line":58,"column":87,"offset":2266},"indent":[]}},{"type":"inlineCode","value":"index.js","position":{"start":{"line":58,"column":87,"offset":2266},"end":{"line":58,"column":97,"offset":2276},"indent":[]}},{"type":"text","value":" file import the proper provider and wrap the root in it like this:","position":{"start":{"line":58,"column":97,"offset":2276},"end":{"line":58,"column":164,"offset":2343},"indent":[]}}],"position":{"start":{"line":58,"column":4,"offset":2183},"end":{"line":58,"column":164,"offset":2343},"indent":[]}}],"position":{"start":{"line":58,"column":1,"offset":2180},"end":{"line":58,"column":164,"offset":2343},"indent":[]}}],"position":{"start":{"line":58,"column":1,"offset":2180},"end":{"line":58,"column":164,"offset":2343},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\nimport registerServiceWorker from './registerServiceWorker'\nimport './index.css'\nimport { ApolloProvider } from 'react-apollo'\nimport { client } from './App'\n\nReactDOM.render(\n  <ApolloProvider client={client}>\n    <App />\n  </ApolloProvider>,\n  document.getElementById('root')\n)\nregisterServiceWorker()","position":{"start":{"line":60,"column":1,"offset":2347},"end":{"line":76,"column":4,"offset":2767},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Writing the queries","position":{"start":{"line":78,"column":5,"offset":2775},"end":{"line":78,"column":24,"offset":2794},"indent":[]}}],"position":{"start":{"line":78,"column":1,"offset":2771},"end":{"line":78,"column":24,"offset":2794},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Next we'll construct our query and fetch data. For this example we will fetch some data about the Dai token on Kwikswap. We'll get the current price, and total liquidity across all pairs. We'll be using the Dai address as an id in this query. We'll also fetch the USD price of ETH to help create USD conversion for Dai data.","position":{"start":{"line":80,"column":1,"offset":2798},"end":{"line":80,"column":325,"offset":3122},"indent":[]}}],"position":{"start":{"line":80,"column":1,"offset":2798},"end":{"line":80,"column":325,"offset":3122},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"First we need to define the query itself. We'll use ","position":{"start":{"line":82,"column":4,"offset":3129},"end":{"line":82,"column":56,"offset":3181},"indent":[]}},{"type":"inlineCode","value":"gql","position":{"start":{"line":82,"column":56,"offset":3181},"end":{"line":82,"column":61,"offset":3186},"indent":[]}},{"type":"text","value":" to parse a query string into the GraphQL AST standard. Import the ","position":{"start":{"line":82,"column":61,"offset":3186},"end":{"line":82,"column":128,"offset":3253},"indent":[]}},{"type":"inlineCode","value":"gql","position":{"start":{"line":82,"column":128,"offset":3253},"end":{"line":82,"column":133,"offset":3258},"indent":[]}},{"type":"text","value":" helper into the app and use it to create the query. Add the following to your ","position":{"start":{"line":82,"column":133,"offset":3258},"end":{"line":82,"column":212,"offset":3337},"indent":[]}},{"type":"inlineCode","value":"App.js","position":{"start":{"line":82,"column":212,"offset":3337},"end":{"line":82,"column":220,"offset":3345},"indent":[]}},{"type":"text","value":" file:","position":{"start":{"line":82,"column":220,"offset":3345},"end":{"line":82,"column":226,"offset":3351},"indent":[]}}],"position":{"start":{"line":82,"column":4,"offset":3129},"end":{"line":82,"column":226,"offset":3351},"indent":[]}}],"position":{"start":{"line":82,"column":1,"offset":3126},"end":{"line":82,"column":226,"offset":3351},"indent":[]}}],"position":{"start":{"line":82,"column":1,"offset":3126},"end":{"line":82,"column":226,"offset":3351},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"import gql from 'graphql-tag'\n\nconst DAI_QUERY = gql`\n  query tokens($tokenAddress: Bytes!) {\n    tokens(where: { id: $tokenAddress }) {\n      derivedETH\n      totalLiquidity\n    }\n  }\n`\n\nconst ETH_PRICE_QUERY = gql`\n  query ethPrice {\n    bundle(id: \"1\") {\n      ethprice\n    }\n  }\n`","position":{"start":{"line":84,"column":1,"offset":3355},"end":{"line":103,"column":4,"offset":3676},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"We use an id of ","position":{"start":{"line":105,"column":1,"offset":3680},"end":{"line":105,"column":17,"offset":3696},"indent":[]}},{"type":"inlineCode","value":"1","position":{"start":{"line":105,"column":17,"offset":3696},"end":{"line":105,"column":20,"offset":3699},"indent":[]}},{"type":"text","value":" for the bundle because there is only one hardcoded bundle in the subgraph.","position":{"start":{"line":105,"column":20,"offset":3699},"end":{"line":105,"column":95,"offset":3774},"indent":[]}}],"position":{"start":{"line":105,"column":1,"offset":3680},"end":{"line":105,"column":95,"offset":3774},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Fetch data","position":{"start":{"line":107,"column":5,"offset":3782},"end":{"line":107,"column":15,"offset":3792},"indent":[]}}],"position":{"start":{"line":107,"column":1,"offset":3778},"end":{"line":107,"column":15,"offset":3792},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Now we're ready to use these queries to fetch data from the Kwikswap subgraph. To do this we can use the ","position":{"start":{"line":109,"column":1,"offset":3796},"end":{"line":109,"column":106,"offset":3901},"indent":[]}},{"type":"inlineCode","value":"useQuery","position":{"start":{"line":109,"column":106,"offset":3901},"end":{"line":109,"column":116,"offset":3911},"indent":[]}},{"type":"text","value":" hook which uses our client instance to fetch data, and gives us live info about the status of the request. To do this add the following to your ","position":{"start":{"line":109,"column":116,"offset":3911},"end":{"line":109,"column":261,"offset":4056},"indent":[]}},{"type":"inlineCode","value":"App.js","position":{"start":{"line":109,"column":261,"offset":4056},"end":{"line":109,"column":269,"offset":4064},"indent":[]}},{"type":"text","value":" file:","position":{"start":{"line":109,"column":269,"offset":4064},"end":{"line":109,"column":275,"offset":4070},"indent":[]}}],"position":{"start":{"line":109,"column":1,"offset":3796},"end":{"line":109,"column":275,"offset":4070},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"import { useQuery } from '@apollo/react-hooks'\n\nconst { loading, error, data: ethPriceData } = useQuery(ETH_PRICE_QUERY)\nconst { loading: daiLoading, error: daiError, data: daiData } = useQuery(DAI_QUERY, {\n  variables: {\n    tokenAddress: '0x6b175474e89094c44da98b954eedeac495271d0f'\n  }\n})","position":{"start":{"line":111,"column":1,"offset":4074},"end":{"line":120,"column":4,"offset":4392},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Notice we're using the Dai token address to fetch data about Dai.","position":{"start":{"line":122,"column":1,"offset":4396},"end":{"line":122,"column":66,"offset":4461},"indent":[]}}],"position":{"start":{"line":122,"column":1,"offset":4396},"end":{"line":122,"column":66,"offset":4461},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Formatting Response","position":{"start":{"line":124,"column":5,"offset":4469},"end":{"line":124,"column":24,"offset":4488},"indent":[]}}],"position":{"start":{"line":124,"column":1,"offset":4465},"end":{"line":124,"column":24,"offset":4488},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Now that we have our data we can format it and display it in the UI. First, we parse the return data to get the actual data that we want. Then we'll use it to get the USD price of Dai. Lastly we'll insert this data into the UI itself.","position":{"start":{"line":126,"column":1,"offset":4492},"end":{"line":126,"column":235,"offset":4726},"indent":[]}}],"position":{"start":{"line":126,"column":1,"offset":4492},"end":{"line":126,"column":235,"offset":4726},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"These queries will return an response object for each query. Within each one we're interested in the root field we defined in the query definition. For the ","position":{"start":{"line":128,"column":1,"offset":4730},"end":{"line":128,"column":157,"offset":4886},"indent":[]}},{"type":"inlineCode","value":"daiData","position":{"start":{"line":128,"column":157,"offset":4886},"end":{"line":128,"column":166,"offset":4895},"indent":[]}},{"type":"text","value":" response we defined this as ","position":{"start":{"line":128,"column":166,"offset":4895},"end":{"line":128,"column":195,"offset":4924},"indent":[]}},{"type":"inlineCode","value":"tokens","position":{"start":{"line":128,"column":195,"offset":4924},"end":{"line":128,"column":203,"offset":4932},"indent":[]}},{"type":"text","value":", and for the ","position":{"start":{"line":128,"column":203,"offset":4932},"end":{"line":128,"column":217,"offset":4946},"indent":[]}},{"type":"inlineCode","value":"ethPriceData","position":{"start":{"line":128,"column":217,"offset":4946},"end":{"line":128,"column":231,"offset":4960},"indent":[]}},{"type":"text","value":" query we defined this as ","position":{"start":{"line":128,"column":231,"offset":4960},"end":{"line":128,"column":257,"offset":4986},"indent":[]}},{"type":"inlineCode","value":"ethPrice","position":{"start":{"line":128,"column":257,"offset":4986},"end":{"line":128,"column":267,"offset":4996},"indent":[]}},{"type":"text","value":". Within each one we'll get an array of results. Because we're only querying for single entities we'll reference the ","position":{"start":{"line":128,"column":267,"offset":4996},"end":{"line":128,"column":384,"offset":5113},"indent":[]}},{"type":"inlineCode","value":"0","position":{"start":{"line":128,"column":384,"offset":5113},"end":{"line":128,"column":387,"offset":5116},"indent":[]}},{"type":"text","value":" index in the data array.","position":{"start":{"line":128,"column":387,"offset":5116},"end":{"line":128,"column":412,"offset":5141},"indent":[]}}],"position":{"start":{"line":128,"column":1,"offset":4730},"end":{"line":128,"column":412,"offset":5141},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Add the following lines to your ","position":{"start":{"line":130,"column":1,"offset":5145},"end":{"line":130,"column":33,"offset":5177},"indent":[]}},{"type":"inlineCode","value":"App.js","position":{"start":{"line":130,"column":33,"offset":5177},"end":{"line":130,"column":41,"offset":5185},"indent":[]}},{"type":"text","value":" file to parse the responses:","position":{"start":{"line":130,"column":41,"offset":5185},"end":{"line":130,"column":70,"offset":5214},"indent":[]}}],"position":{"start":{"line":130,"column":1,"offset":5145},"end":{"line":130,"column":70,"offset":5214},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"const daiPriceInEth = daiData && daiData.tokens[0].derivedETH\nconst daiTotalLiquidity = daiData && daiData.tokens[0].totalLiquidity\nconst ethPriceInUSD = ethPriceData && ethPriceData.bundles[0].ethPrice","position":{"start":{"line":132,"column":1,"offset":5218},"end":{"line":136,"column":4,"offset":5442},"indent":[1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Displaying in the UI","position":{"start":{"line":138,"column":5,"offset":5450},"end":{"line":138,"column":25,"offset":5470},"indent":[]}}],"position":{"start":{"line":138,"column":1,"offset":5446},"end":{"line":138,"column":25,"offset":5470},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Finally we can use our parsed response data to hydrate the UI. We'll do this in two steps.","position":{"start":{"line":140,"column":1,"offset":5474},"end":{"line":140,"column":91,"offset":5564},"indent":[]}}],"position":{"start":{"line":140,"column":1,"offset":5474},"end":{"line":140,"column":91,"offset":5564},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":true,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"First we'll create loading states. To detect if a query is still pending a response we can reference the loading variables we've already defined. We'll add two loading states, one for the Dai price, and one for the Dai total liquidity. These may flicker fast because the time to query is fast.","position":{"start":{"line":142,"column":4,"offset":5571},"end":{"line":142,"column":297,"offset":5864},"indent":[]}}],"position":{"start":{"line":142,"column":4,"offset":5571},"end":{"line":142,"column":297,"offset":5864},"indent":[]}}],"position":{"start":{"line":142,"column":1,"offset":5568},"end":{"line":143,"column":1,"offset":5866},"indent":[1]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Populate with loaded data. Once we detect that the queries have finished loading we can populate the UI with the real data.","position":{"start":{"line":144,"column":4,"offset":5871},"end":{"line":144,"column":127,"offset":5994},"indent":[]}}],"position":{"start":{"line":144,"column":4,"offset":5871},"end":{"line":144,"column":127,"offset":5994},"indent":[]}}],"position":{"start":{"line":144,"column":1,"offset":5868},"end":{"line":144,"column":127,"offset":5994},"indent":[]}}],"position":{"start":{"line":142,"column":1,"offset":5568},"end":{"line":144,"column":127,"offset":5994},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"To do this add the following lines in the return function of your ","position":{"start":{"line":146,"column":1,"offset":5998},"end":{"line":146,"column":67,"offset":6064},"indent":[]}},{"type":"inlineCode","value":"App.js","position":{"start":{"line":146,"column":67,"offset":6064},"end":{"line":146,"column":75,"offset":6072},"indent":[]}},{"type":"text","value":" file:","position":{"start":{"line":146,"column":75,"offset":6072},"end":{"line":146,"column":81,"offset":6078},"indent":[]}}],"position":{"start":{"line":146,"column":1,"offset":5998},"end":{"line":146,"column":81,"offset":6078},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"return (\n  <div>\n    <div>\n      Dai price:{' '}\n      {ethLoading || daiLoading\n        ? 'Loading token data...'\n        : '$' +\n          // parse responses as floats and fix to 2 decimals\n          (parseFloat(daiPriceInEth) * parseFloat(ethPriceInUSD)).toFixed(2)}\n    </div>\n    <div>\n      Dai total liquidity:{' '}\n      {daiLoading\n        ? 'Loading token data...'\n        : // display the total amount of DAI spread across all pools\n          parseFloat(daiTotalLiquidity).toFixed(0)}\n    </div>\n  </div>\n)","position":{"start":{"line":148,"column":1,"offset":6082},"end":{"line":168,"column":4,"offset":6637},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Next steps","position":{"start":{"line":170,"column":5,"offset":6645},"end":{"line":170,"column":15,"offset":6655},"indent":[]}}],"position":{"start":{"line":170,"column":1,"offset":6641},"end":{"line":170,"column":15,"offset":6655},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This should render a very basic page with these two stats about the Dai token within Kwikswap. This is a very basic example of what you can do with the Kwikswap subgraph and we encourage you to build out more complex and interesting tools!","position":{"start":{"line":172,"column":1,"offset":6659},"end":{"line":172,"column":240,"offset":6898},"indent":[]}}],"position":{"start":{"line":172,"column":1,"offset":6659},"end":{"line":172,"column":240,"offset":6898},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"You can visit our ","position":{"start":{"line":174,"column":1,"offset":6902},"end":{"line":174,"column":19,"offset":6920},"indent":[]}},{"type":"link","title":null,"url":"https://kwikswap.info/","children":[{"type":"text","value":"analytics site","position":{"start":{"line":174,"column":20,"offset":6921},"end":{"line":174,"column":34,"offset":6935},"indent":[]}}],"position":{"start":{"line":174,"column":19,"offset":6920},"end":{"line":174,"column":59,"offset":6960},"indent":[]}},{"type":"text","value":" to see a more advanced analytics page, or visit ","position":{"start":{"line":174,"column":59,"offset":6960},"end":{"line":174,"column":108,"offset":7009},"indent":[]}},{"type":"link","title":null,"url":"https://github.com/Kwikswap/kwikswap-info","children":[{"type":"text","value":"the github","position":{"start":{"line":174,"column":109,"offset":7010},"end":{"line":174,"column":119,"offset":7020},"indent":[]}}],"position":{"start":{"line":174,"column":108,"offset":7009},"end":{"line":174,"column":163,"offset":7064},"indent":[]}},{"type":"text","value":" for more detailed examples of using the Kwikswap subgraph to create UIs.","position":{"start":{"line":174,"column":163,"offset":7064},"end":{"line":174,"column":236,"offset":7137},"indent":[]}}],"position":{"start":{"line":174,"column":1,"offset":6902},"end":{"line":174,"column":236,"offset":7137},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Review","position":{"start":{"line":176,"column":5,"offset":7145},"end":{"line":176,"column":11,"offset":7151},"indent":[]}}],"position":{"start":{"line":176,"column":1,"offset":7141},"end":{"line":176,"column":11,"offset":7151},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In the end your ","position":{"start":{"line":178,"column":1,"offset":7155},"end":{"line":178,"column":17,"offset":7171},"indent":[]}},{"type":"inlineCode","value":"App.js","position":{"start":{"line":178,"column":17,"offset":7171},"end":{"line":178,"column":25,"offset":7179},"indent":[]}},{"type":"text","value":" file should look like this:","position":{"start":{"line":178,"column":25,"offset":7179},"end":{"line":178,"column":53,"offset":7207},"indent":[]}}],"position":{"start":{"line":178,"column":1,"offset":7155},"end":{"line":178,"column":53,"offset":7207},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"import React, { useEffect } from 'react'\nimport './App.css'\nimport { ApolloClient } from 'apollo-client'\nimport { InMemoryCache } from 'apollo-cache-inmemory'\nimport { HttpLink } from 'apollo-link-http'\nimport { useQuery } from '@apollo/react-hooks'\nimport gql from 'graphql-tag'\n\nexport const client = new ApolloClient({\n  link: new HttpLink({\n    uri: 'https://api.thegraph.com/subgraphs/name/kwikswap/kwikswap-subgraph'\n  }),\n  fetchOptions: {\n    mode: 'no-cors'\n  },\n  cache: new InMemoryCache()\n})\n\nconst DAI_QUERY = gql`\n  query tokens($tokenAddress: Bytes!) {\n    tokens(where: { id: $tokenAddress }) {\n      derivedETH\n      totalLiquidity\n    }\n  }\n`\n\nconst ETH_PRICE_QUERY = gql`\n  query bundles {\n    bundles(where: { id: \"1\" }) {\n      ethPrice\n    }\n  }\n`\n\nfunction App() {\n  const { loading: ethLoading, data: ethPriceData } = useQuery(ETH_PRICE_QUERY)\n  const { loading: daiLoading, data: daiData } = useQuery(DAI_QUERY, {\n    variables: {\n      tokenAddress: '0x6b175474e89094c44da98b954eedeac495271d0f'\n    }\n  })\n\n  const daiPriceInEth = daiData && daiData.tokens[0].derivedETH\n  const daiTotalLiquidity = daiData && daiData.tokens[0].totalLiquidity\n  const ethPriceInUSD = ethPriceData && ethPriceData.bundles[0].ethPrice\n\n  return (\n    <div>\n      <div>\n        Dai price:{' '}\n        {ethLoading || daiLoading\n          ? 'Loading token data...'\n          : '$' +\n            // parse responses as floats and fix to 2 decimals\n            (parseFloat(daiPriceInEth) * parseFloat(ethPriceInUSD)).toFixed(2)}\n      </div>\n      <div>\n        Dai total liquidity:{' '}\n        {daiLoading\n          ? 'Loading token data...'\n          : // display the total amount of DAI spread across all pools\n            parseFloat(daiTotalLiquidity).toFixed(0)}\n      </div>\n    </div>\n  )\n}\n\nexport default App","position":{"start":{"line":180,"column":1,"offset":7211},"end":{"line":250,"column":4,"offset":9119},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"Using the API\",\"tags\":\"user-guides, documentation\"}","position":{"start":{"line":253,"column":1,"offset":9123},"end":{"line":253,"column":90,"offset":9212},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":253,"column":90,"offset":9212}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Using the API\",\n  \"tags\": \"user-guides, documentation\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In this guide we will create a web interface that consumes and displays data from the Kwikswap Subgraph. The goal is to provide a quick overview of a setup that you can extend to create your own UIs and analytics around Kwikswap data.\"), mdx(\"p\", null, \"Many different libraries can be used to create an interface and a connection to the subgraph graphql endpoint, but in this guide we will use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/\"\n  }, \"React\"), \" for the interface, and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.apollographql.com/docs/react/\"\n  }, \"Apollo Client\"), \" for sending queries. We\\u2019ll also be using yarn for dependency management.\"), mdx(\"h3\", {\n    \"id\": \"setup-and-installs\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#setup-and-installs\",\n    \"aria-label\": \"setup and installs permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Setup and Installs\"), mdx(\"p\", null, \"We\\u2019ll need to create the basic skeleton for the application. We\\u2019ll use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/docs/create-a-new-react-app.html\"\n  }, \"create-react-app\"), \" for this. We\\u2019ll also add the dependencies we need. Navigate to your root location in your command line and run:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"yarn create react-app kwikswap-demo\\ncd kwikswap-demo\\nyarn add  apollo-client apollo-cache-inmemory apollo-link-http graphql graphql-tag @apollo/react-hooks\\nyarn start\\n\")), mdx(\"p\", null, \"In your browser you should see the default React app running. In a text editor open \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App.js\"), \" within \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src\"), \" and replace the contents with this stripped down boilerplate. We\\u2019ll add to this as we go.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"import React from 'react'\\nimport './App.css'\\n\\nfunction App() {\\n  return <div></div>\\n}\\n\\nexport default App\\n\")), mdx(\"h3\", {\n    \"id\": \"graphql-client\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#graphql-client\",\n    \"aria-label\": \"graphql client permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Graphql Client\"), mdx(\"p\", null, \"We need to set up some middleware in order to make requests to the Kwikswap subgraph and receive data. To do this we\\u2019ll use Apollo and create a graphql client to handle this.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Add the imports shown below and instantiate a new client instance. Notice how we use the link to the Kwikswap subgraph here.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"import React from \\\"react\\\"\\nimport \\\"./App.css\\\"\\nimport { ApolloClient } from \\\"apollo-client\\\"\\nimport { InMemoryCache } from \\\"apollo-cache-inmemory\\\"\\nimport { HttpLink } from \\\"apollo-link-http\\\"\\n\\nexport const client = new ApolloClient({\\n link: new HttpLink({\\n   uri: \\\"https://thegraph.com/explorer/subgraph/kwikswap/kwikswap-subgraph\\\"\\n }),\\n cache: new InMemoryCache(),\\n})\\n\\nfunction App() {\\n return <div></div>\\n}\\n\\nexport default App\\n\\n\")), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"We also need to add a context so that Apollo can handle requests properly. In your \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"index.js\"), \" file import the proper provider and wrap the root in it like this:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"import React from 'react'\\nimport ReactDOM from 'react-dom'\\nimport App from './App'\\nimport registerServiceWorker from './registerServiceWorker'\\nimport './index.css'\\nimport { ApolloProvider } from 'react-apollo'\\nimport { client } from './App'\\n\\nReactDOM.render(\\n  <ApolloProvider client={client}>\\n    <App />\\n  </ApolloProvider>,\\n  document.getElementById('root')\\n)\\nregisterServiceWorker()\\n\")), mdx(\"h3\", {\n    \"id\": \"writing-the-queries\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#writing-the-queries\",\n    \"aria-label\": \"writing the queries permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Writing the queries\"), mdx(\"p\", null, \"Next we\\u2019ll construct our query and fetch data. For this example we will fetch some data about the Dai token on Kwikswap. We\\u2019ll get the current price, and total liquidity across all pairs. We\\u2019ll be using the Dai address as an id in this query. We\\u2019ll also fetch the USD price of ETH to help create USD conversion for Dai data.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"First we need to define the query itself. We\\u2019ll use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"gql\"), \" to parse a query string into the GraphQL AST standard. Import the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"gql\"), \" helper into the app and use it to create the query. Add the following to your \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"App.js\"), \" file:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"import gql from 'graphql-tag'\\n\\nconst DAI_QUERY = gql`\\n  query tokens($tokenAddress: Bytes!) {\\n    tokens(where: { id: $tokenAddress }) {\\n      derivedETH\\n      totalLiquidity\\n    }\\n  }\\n`\\n\\nconst ETH_PRICE_QUERY = gql`\\n  query ethPrice {\\n    bundle(id: \\\"1\\\") {\\n      ethprice\\n    }\\n  }\\n`\\n\")), mdx(\"p\", null, \"We use an id of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \" for the bundle because there is only one hardcoded bundle in the subgraph.\"), mdx(\"h3\", {\n    \"id\": \"fetch-data\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#fetch-data\",\n    \"aria-label\": \"fetch data permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Fetch data\"), mdx(\"p\", null, \"Now we\\u2019re ready to use these queries to fetch data from the Kwikswap subgraph. To do this we can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" hook which uses our client instance to fetch data, and gives us live info about the status of the request. To do this add the following to your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App.js\"), \" file:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"import { useQuery } from '@apollo/react-hooks'\\n\\nconst { loading, error, data: ethPriceData } = useQuery(ETH_PRICE_QUERY)\\nconst { loading: daiLoading, error: daiError, data: daiData } = useQuery(DAI_QUERY, {\\n  variables: {\\n    tokenAddress: '0x6b175474e89094c44da98b954eedeac495271d0f'\\n  }\\n})\\n\")), mdx(\"p\", null, \"Notice we\\u2019re using the Dai token address to fetch data about Dai.\"), mdx(\"h3\", {\n    \"id\": \"formatting-response\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#formatting-response\",\n    \"aria-label\": \"formatting response permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Formatting Response\"), mdx(\"p\", null, \"Now that we have our data we can format it and display it in the UI. First, we parse the return data to get the actual data that we want. Then we\\u2019ll use it to get the USD price of Dai. Lastly we\\u2019ll insert this data into the UI itself.\"), mdx(\"p\", null, \"These queries will return an response object for each query. Within each one we\\u2019re interested in the root field we defined in the query definition. For the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"daiData\"), \" response we defined this as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tokens\"), \", and for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ethPriceData\"), \" query we defined this as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ethPrice\"), \". Within each one we\\u2019ll get an array of results. Because we\\u2019re only querying for single entities we\\u2019ll reference the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \" index in the data array.\"), mdx(\"p\", null, \"Add the following lines to your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App.js\"), \" file to parse the responses:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"const daiPriceInEth = daiData && daiData.tokens[0].derivedETH\\nconst daiTotalLiquidity = daiData && daiData.tokens[0].totalLiquidity\\nconst ethPriceInUSD = ethPriceData && ethPriceData.bundles[0].ethPrice\\n\")), mdx(\"h3\", {\n    \"id\": \"displaying-in-the-ui\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#displaying-in-the-ui\",\n    \"aria-label\": \"displaying in the ui permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Displaying in the UI\"), mdx(\"p\", null, \"Finally we can use our parsed response data to hydrate the UI. We\\u2019ll do this in two steps.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"First we\\u2019ll create loading states. To detect if a query is still pending a response we can reference the loading variables we\\u2019ve already defined. We\\u2019ll add two loading states, one for the Dai price, and one for the Dai total liquidity. These may flicker fast because the time to query is fast.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Populate with loaded data. Once we detect that the queries have finished loading we can populate the UI with the real data.\"))), mdx(\"p\", null, \"To do this add the following lines in the return function of your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App.js\"), \" file:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"return (\\n  <div>\\n    <div>\\n      Dai price:{' '}\\n      {ethLoading || daiLoading\\n        ? 'Loading token data...'\\n        : '$' +\\n          // parse responses as floats and fix to 2 decimals\\n          (parseFloat(daiPriceInEth) * parseFloat(ethPriceInUSD)).toFixed(2)}\\n    </div>\\n    <div>\\n      Dai total liquidity:{' '}\\n      {daiLoading\\n        ? 'Loading token data...'\\n        : // display the total amount of DAI spread across all pools\\n          parseFloat(daiTotalLiquidity).toFixed(0)}\\n    </div>\\n  </div>\\n)\\n\")), mdx(\"h3\", {\n    \"id\": \"next-steps\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#next-steps\",\n    \"aria-label\": \"next steps permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Next steps\"), mdx(\"p\", null, \"This should render a very basic page with these two stats about the Dai token within Kwikswap. This is a very basic example of what you can do with the Kwikswap subgraph and we encourage you to build out more complex and interesting tools!\"), mdx(\"p\", null, \"You can visit our \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://kwikswap.info/\"\n  }, \"analytics site\"), \" to see a more advanced analytics page, or visit \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/Kwikswap/kwikswap-info\"\n  }, \"the github\"), \" for more detailed examples of using the Kwikswap subgraph to create UIs.\"), mdx(\"h3\", {\n    \"id\": \"review\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#review\",\n    \"aria-label\": \"review permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Review\"), mdx(\"p\", null, \"In the end your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App.js\"), \" file should look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"import React, { useEffect } from 'react'\\nimport './App.css'\\nimport { ApolloClient } from 'apollo-client'\\nimport { InMemoryCache } from 'apollo-cache-inmemory'\\nimport { HttpLink } from 'apollo-link-http'\\nimport { useQuery } from '@apollo/react-hooks'\\nimport gql from 'graphql-tag'\\n\\nexport const client = new ApolloClient({\\n  link: new HttpLink({\\n    uri: 'https://api.thegraph.com/subgraphs/name/kwikswap/kwikswap-subgraph'\\n  }),\\n  fetchOptions: {\\n    mode: 'no-cors'\\n  },\\n  cache: new InMemoryCache()\\n})\\n\\nconst DAI_QUERY = gql`\\n  query tokens($tokenAddress: Bytes!) {\\n    tokens(where: { id: $tokenAddress }) {\\n      derivedETH\\n      totalLiquidity\\n    }\\n  }\\n`\\n\\nconst ETH_PRICE_QUERY = gql`\\n  query bundles {\\n    bundles(where: { id: \\\"1\\\" }) {\\n      ethPrice\\n    }\\n  }\\n`\\n\\nfunction App() {\\n  const { loading: ethLoading, data: ethPriceData } = useQuery(ETH_PRICE_QUERY)\\n  const { loading: daiLoading, data: daiData } = useQuery(DAI_QUERY, {\\n    variables: {\\n      tokenAddress: '0x6b175474e89094c44da98b954eedeac495271d0f'\\n    }\\n  })\\n\\n  const daiPriceInEth = daiData && daiData.tokens[0].derivedETH\\n  const daiTotalLiquidity = daiData && daiData.tokens[0].totalLiquidity\\n  const ethPriceInUSD = ethPriceData && ethPriceData.bundles[0].ethPrice\\n\\n  return (\\n    <div>\\n      <div>\\n        Dai price:{' '}\\n        {ethLoading || daiLoading\\n          ? 'Loading token data...'\\n          : '$' +\\n            // parse responses as floats and fix to 2 decimals\\n            (parseFloat(daiPriceInEth) * parseFloat(ethPriceInUSD)).toFixed(2)}\\n      </div>\\n      <div>\\n        Dai total liquidity:{' '}\\n        {daiLoading\\n          ? 'Loading token data...'\\n          : // display the total amount of DAI spread across all pools\\n            parseFloat(daiTotalLiquidity).toFixed(0)}\\n      </div>\\n    </div>\\n  )\\n}\\n\\nexport default App\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"Using the API\",\n  \"tags\": \"user-guides, documentation\"\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`In this guide we will create a web interface that consumes and displays data from the Kwikswap Subgraph. The goal is to provide a quick overview of a setup that you can extend to create your own UIs and analytics around Kwikswap data.`}</p>\n    <p>{`Many different libraries can be used to create an interface and a connection to the subgraph graphql endpoint, but in this guide we will use `}<a parentName=\"p\" {...{\n        \"href\": \"https://reactjs.org/\"\n      }}>{`React`}</a>{` for the interface, and `}<a parentName=\"p\" {...{\n        \"href\": \"https://www.apollographql.com/docs/react/\"\n      }}>{`Apollo Client`}</a>{` for sending queries. We’ll also be using yarn for dependency management.`}</p>\n    <h3 {...{\n      \"id\": \"setup-and-installs\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h3\" {...{\n        \"href\": \"#setup-and-installs\",\n        \"aria-label\": \"setup and installs permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Setup and Installs`}</h3>\n    <p>{`We’ll need to create the basic skeleton for the application. We’ll use `}<a parentName=\"p\" {...{\n        \"href\": \"https://reactjs.org/docs/create-a-new-react-app.html\"\n      }}>{`create-react-app`}</a>{` for this. We’ll also add the dependencies we need. Navigate to your root location in your command line and run:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`yarn create react-app kwikswap-demo\ncd kwikswap-demo\nyarn add  apollo-client apollo-cache-inmemory apollo-link-http graphql graphql-tag @apollo/react-hooks\nyarn start\n`}</code></pre>\n    <p>{`In your browser you should see the default React app running. In a text editor open `}<inlineCode parentName=\"p\">{`App.js`}</inlineCode>{` within `}<inlineCode parentName=\"p\">{`src`}</inlineCode>{` and replace the contents with this stripped down boilerplate. We’ll add to this as we go.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import React from 'react'\nimport './App.css'\n\nfunction App() {\n  return <div></div>\n}\n\nexport default App\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"graphql-client\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h3\" {...{\n        \"href\": \"#graphql-client\",\n        \"aria-label\": \"graphql client permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Graphql Client`}</h3>\n    <p>{`We need to set up some middleware in order to make requests to the Kwikswap subgraph and receive data. To do this we’ll use Apollo and create a graphql client to handle this.`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Add the imports shown below and instantiate a new client instance. Notice how we use the link to the Kwikswap subgraph here.`}</li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import React from \"react\"\nimport \"./App.css\"\nimport { ApolloClient } from \"apollo-client\"\nimport { InMemoryCache } from \"apollo-cache-inmemory\"\nimport { HttpLink } from \"apollo-link-http\"\n\nexport const client = new ApolloClient({\n link: new HttpLink({\n   uri: \"https://thegraph.com/explorer/subgraph/kwikswap/kwikswap-subgraph\"\n }),\n cache: new InMemoryCache(),\n})\n\nfunction App() {\n return <div></div>\n}\n\nexport default App\n\n`}</code></pre>\n    <ol {...{\n      \"start\": 2\n    }}>\n      <li parentName=\"ol\">{`We also need to add a context so that Apollo can handle requests properly. In your `}<inlineCode parentName=\"li\">{`index.js`}</inlineCode>{` file import the proper provider and wrap the root in it like this:`}</li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\nimport registerServiceWorker from './registerServiceWorker'\nimport './index.css'\nimport { ApolloProvider } from 'react-apollo'\nimport { client } from './App'\n\nReactDOM.render(\n  <ApolloProvider client={client}>\n    <App />\n  </ApolloProvider>,\n  document.getElementById('root')\n)\nregisterServiceWorker()\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"writing-the-queries\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h3\" {...{\n        \"href\": \"#writing-the-queries\",\n        \"aria-label\": \"writing the queries permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Writing the queries`}</h3>\n    <p>{`Next we’ll construct our query and fetch data. For this example we will fetch some data about the Dai token on Kwikswap. We’ll get the current price, and total liquidity across all pairs. We’ll be using the Dai address as an id in this query. We’ll also fetch the USD price of ETH to help create USD conversion for Dai data.`}</p>\n    <ol>\n      <li parentName=\"ol\">{`First we need to define the query itself. We’ll use `}<inlineCode parentName=\"li\">{`gql`}</inlineCode>{` to parse a query string into the GraphQL AST standard. Import the `}<inlineCode parentName=\"li\">{`gql`}</inlineCode>{` helper into the app and use it to create the query. Add the following to your `}<inlineCode parentName=\"li\">{`App.js`}</inlineCode>{` file:`}</li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import gql from 'graphql-tag'\n\nconst DAI_QUERY = gql\\`\n  query tokens($tokenAddress: Bytes!) {\n    tokens(where: { id: $tokenAddress }) {\n      derivedETH\n      totalLiquidity\n    }\n  }\n\\`\n\nconst ETH_PRICE_QUERY = gql\\`\n  query ethPrice {\n    bundle(id: \"1\") {\n      ethprice\n    }\n  }\n\\`\n`}</code></pre>\n    <p>{`We use an id of `}<inlineCode parentName=\"p\">{`1`}</inlineCode>{` for the bundle because there is only one hardcoded bundle in the subgraph.`}</p>\n    <h3 {...{\n      \"id\": \"fetch-data\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h3\" {...{\n        \"href\": \"#fetch-data\",\n        \"aria-label\": \"fetch data permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Fetch data`}</h3>\n    <p>{`Now we’re ready to use these queries to fetch data from the Kwikswap subgraph. To do this we can use the `}<inlineCode parentName=\"p\">{`useQuery`}</inlineCode>{` hook which uses our client instance to fetch data, and gives us live info about the status of the request. To do this add the following to your `}<inlineCode parentName=\"p\">{`App.js`}</inlineCode>{` file:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import { useQuery } from '@apollo/react-hooks'\n\nconst { loading, error, data: ethPriceData } = useQuery(ETH_PRICE_QUERY)\nconst { loading: daiLoading, error: daiError, data: daiData } = useQuery(DAI_QUERY, {\n  variables: {\n    tokenAddress: '0x6b175474e89094c44da98b954eedeac495271d0f'\n  }\n})\n`}</code></pre>\n    <p>{`Notice we’re using the Dai token address to fetch data about Dai.`}</p>\n    <h3 {...{\n      \"id\": \"formatting-response\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h3\" {...{\n        \"href\": \"#formatting-response\",\n        \"aria-label\": \"formatting response permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Formatting Response`}</h3>\n    <p>{`Now that we have our data we can format it and display it in the UI. First, we parse the return data to get the actual data that we want. Then we’ll use it to get the USD price of Dai. Lastly we’ll insert this data into the UI itself.`}</p>\n    <p>{`These queries will return an response object for each query. Within each one we’re interested in the root field we defined in the query definition. For the `}<inlineCode parentName=\"p\">{`daiData`}</inlineCode>{` response we defined this as `}<inlineCode parentName=\"p\">{`tokens`}</inlineCode>{`, and for the `}<inlineCode parentName=\"p\">{`ethPriceData`}</inlineCode>{` query we defined this as `}<inlineCode parentName=\"p\">{`ethPrice`}</inlineCode>{`. Within each one we’ll get an array of results. Because we’re only querying for single entities we’ll reference the `}<inlineCode parentName=\"p\">{`0`}</inlineCode>{` index in the data array.`}</p>\n    <p>{`Add the following lines to your `}<inlineCode parentName=\"p\">{`App.js`}</inlineCode>{` file to parse the responses:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const daiPriceInEth = daiData && daiData.tokens[0].derivedETH\nconst daiTotalLiquidity = daiData && daiData.tokens[0].totalLiquidity\nconst ethPriceInUSD = ethPriceData && ethPriceData.bundles[0].ethPrice\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"displaying-in-the-ui\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h3\" {...{\n        \"href\": \"#displaying-in-the-ui\",\n        \"aria-label\": \"displaying in the ui permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Displaying in the UI`}</h3>\n    <p>{`Finally we can use our parsed response data to hydrate the UI. We’ll do this in two steps.`}</p>\n    <ol>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`First we’ll create loading states. To detect if a query is still pending a response we can reference the loading variables we’ve already defined. We’ll add two loading states, one for the Dai price, and one for the Dai total liquidity. These may flicker fast because the time to query is fast.`}</p>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`Populate with loaded data. Once we detect that the queries have finished loading we can populate the UI with the real data.`}</p>\n      </li>\n    </ol>\n    <p>{`To do this add the following lines in the return function of your `}<inlineCode parentName=\"p\">{`App.js`}</inlineCode>{` file:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`return (\n  <div>\n    <div>\n      Dai price:{' '}\n      {ethLoading || daiLoading\n        ? 'Loading token data...'\n        : '$' +\n          // parse responses as floats and fix to 2 decimals\n          (parseFloat(daiPriceInEth) * parseFloat(ethPriceInUSD)).toFixed(2)}\n    </div>\n    <div>\n      Dai total liquidity:{' '}\n      {daiLoading\n        ? 'Loading token data...'\n        : // display the total amount of DAI spread across all pools\n          parseFloat(daiTotalLiquidity).toFixed(0)}\n    </div>\n  </div>\n)\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"next-steps\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h3\" {...{\n        \"href\": \"#next-steps\",\n        \"aria-label\": \"next steps permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Next steps`}</h3>\n    <p>{`This should render a very basic page with these two stats about the Dai token within Kwikswap. This is a very basic example of what you can do with the Kwikswap subgraph and we encourage you to build out more complex and interesting tools!`}</p>\n    <p>{`You can visit our `}<a parentName=\"p\" {...{\n        \"href\": \"https://kwikswap.info/\"\n      }}>{`analytics site`}</a>{` to see a more advanced analytics page, or visit `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/Kwikswap/kwikswap-info\"\n      }}>{`the github`}</a>{` for more detailed examples of using the Kwikswap subgraph to create UIs.`}</p>\n    <h3 {...{\n      \"id\": \"review\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h3\" {...{\n        \"href\": \"#review\",\n        \"aria-label\": \"review permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Review`}</h3>\n    <p>{`In the end your `}<inlineCode parentName=\"p\">{`App.js`}</inlineCode>{` file should look like this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import React, { useEffect } from 'react'\nimport './App.css'\nimport { ApolloClient } from 'apollo-client'\nimport { InMemoryCache } from 'apollo-cache-inmemory'\nimport { HttpLink } from 'apollo-link-http'\nimport { useQuery } from '@apollo/react-hooks'\nimport gql from 'graphql-tag'\n\nexport const client = new ApolloClient({\n  link: new HttpLink({\n    uri: 'https://api.thegraph.com/subgraphs/name/kwikswap/kwikswap-subgraph'\n  }),\n  fetchOptions: {\n    mode: 'no-cors'\n  },\n  cache: new InMemoryCache()\n})\n\nconst DAI_QUERY = gql\\`\n  query tokens($tokenAddress: Bytes!) {\n    tokens(where: { id: $tokenAddress }) {\n      derivedETH\n      totalLiquidity\n    }\n  }\n\\`\n\nconst ETH_PRICE_QUERY = gql\\`\n  query bundles {\n    bundles(where: { id: \"1\" }) {\n      ethPrice\n    }\n  }\n\\`\n\nfunction App() {\n  const { loading: ethLoading, data: ethPriceData } = useQuery(ETH_PRICE_QUERY)\n  const { loading: daiLoading, data: daiData } = useQuery(DAI_QUERY, {\n    variables: {\n      tokenAddress: '0x6b175474e89094c44da98b954eedeac495271d0f'\n    }\n  })\n\n  const daiPriceInEth = daiData && daiData.tokens[0].derivedETH\n  const daiTotalLiquidity = daiData && daiData.tokens[0].totalLiquidity\n  const ethPriceInUSD = ethPriceData && ethPriceData.bundles[0].ethPrice\n\n  return (\n    <div>\n      <div>\n        Dai price:{' '}\n        {ethLoading || daiLoading\n          ? 'Loading token data...'\n          : '$' +\n            // parse responses as floats and fix to 2 decimals\n            (parseFloat(daiPriceInEth) * parseFloat(ethPriceInUSD)).toFixed(2)}\n      </div>\n      <div>\n        Dai total liquidity:{' '}\n        {daiLoading\n          ? 'Loading token data...'\n          : // display the total amount of DAI spread across all pools\n            parseFloat(daiTotalLiquidity).toFixed(0)}\n      </div>\n    </div>\n  )\n}\n\nexport default App\n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}