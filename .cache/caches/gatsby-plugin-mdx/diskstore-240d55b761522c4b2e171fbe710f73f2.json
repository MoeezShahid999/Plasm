{"expireTime":9007200872306494000,"key":"gatsby-plugin-mdx-entire-payload-4e9316e21dfb0f2e864cbd6aca82e556-","val":{"mdast":{"type":"root","children":[{"type":"heading","depth":1,"children":[{"type":"text","value":"Introduction","position":{"start":{"line":2,"column":3,"offset":4},"end":{"line":2,"column":15,"offset":16},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":2},"end":{"line":2,"column":15,"offset":16},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"When providing liquidity from a smart contract, the most important thing to keep in mind is that tokens deposited into a pool at any rate other than the current reserve ratio ","position":{"start":{"line":4,"column":1,"offset":20},"end":{"line":4,"column":176,"offset":195},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"are vulnerable to being arbitraged","position":{"start":{"line":4,"column":177,"offset":196},"end":{"line":4,"column":211,"offset":230},"indent":[]}}],"position":{"start":{"line":4,"column":176,"offset":195},"end":{"line":4,"column":212,"offset":231},"indent":[]}},{"type":"text","value":". As an example, if the ratio of x:y in a pair is 10:2 (i.e. the price is 5), and someone naively adds liquidity at 5:2 (a price of 2.5), the contract will simply accept all tokens (changing the price to 3.75 and opening up the market to arbitrage), but only issue pool tokens entitling the sender to the amount of assets sent at the proper ratio, in this case 5:1. To avoid donating to arbitrageurs, it is imperative to add liquidity at the current price. Luckily, it's easy to ensure that this condition is met!","position":{"start":{"line":4,"column":212,"offset":231},"end":{"line":4,"column":725,"offset":744},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":20},"end":{"line":4,"column":725,"offset":744},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Using the Router","position":{"start":{"line":6,"column":3,"offset":750},"end":{"line":6,"column":19,"offset":766},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":748},"end":{"line":6,"column":19,"offset":766},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The easiest way to safely add liquidity to a pool is to use the ","position":{"start":{"line":8,"column":1,"offset":770},"end":{"line":8,"column":65,"offset":834},"indent":[]}},{"type":"jsx","value":"<Link to='/docs/v1/smart-contracts/router02'>","position":{"start":{"line":8,"column":65,"offset":834},"end":{"line":8,"column":110,"offset":879},"indent":[]}},{"type":"text","value":"router","position":{"start":{"line":8,"column":110,"offset":879},"end":{"line":8,"column":116,"offset":885},"indent":[]}},{"type":"jsx","value":"</Link>","position":{"start":{"line":8,"column":116,"offset":885},"end":{"line":8,"column":123,"offset":892},"indent":[]}},{"type":"text","value":", which provides simple methods to safely add liquidity to a pool. If the liquidity is to be added to an ERC-20/ERC-20 pair, use ","position":{"start":{"line":8,"column":123,"offset":892},"end":{"line":8,"column":252,"offset":1021},"indent":[]}},{"type":"jsx","value":"<Link to='/docs/v1/smart-contracts/router02/#addliquidity'>","position":{"start":{"line":8,"column":252,"offset":1021},"end":{"line":8,"column":311,"offset":1080},"indent":[]}},{"type":"text","value":"addLiquidity","position":{"start":{"line":8,"column":311,"offset":1080},"end":{"line":8,"column":323,"offset":1092},"indent":[]}},{"type":"jsx","value":"</Link>","position":{"start":{"line":8,"column":323,"offset":1092},"end":{"line":8,"column":330,"offset":1099},"indent":[]}},{"type":"text","value":". If WETH is involved, use ","position":{"start":{"line":8,"column":330,"offset":1099},"end":{"line":8,"column":357,"offset":1126},"indent":[]}},{"type":"jsx","value":"<Link to='/docs/v1/smart-contracts/router02/#addliquidityeth'>","position":{"start":{"line":8,"column":357,"offset":1126},"end":{"line":8,"column":419,"offset":1188},"indent":[]}},{"type":"text","value":"addLiquidityETH","position":{"start":{"line":8,"column":419,"offset":1188},"end":{"line":8,"column":434,"offset":1203},"indent":[]}},{"type":"jsx","value":"</Link>","position":{"start":{"line":8,"column":434,"offset":1203},"end":{"line":8,"column":441,"offset":1210},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":8,"column":441,"offset":1210},"end":{"line":8,"column":442,"offset":1211},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":770},"end":{"line":8,"column":442,"offset":1211},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"These methods both require the caller to commit to a ","position":{"start":{"line":10,"column":1,"offset":1215},"end":{"line":10,"column":54,"offset":1268},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"belief about the current price","position":{"start":{"line":10,"column":55,"offset":1269},"end":{"line":10,"column":85,"offset":1299},"indent":[]}}],"position":{"start":{"line":10,"column":54,"offset":1268},"end":{"line":10,"column":86,"offset":1300},"indent":[]}},{"type":"text","value":", which is encoded in the ","position":{"start":{"line":10,"column":86,"offset":1300},"end":{"line":10,"column":112,"offset":1326},"indent":[]}},{"type":"inlineCode","value":"amount*Desired","position":{"start":{"line":10,"column":112,"offset":1326},"end":{"line":10,"column":128,"offset":1342},"indent":[]}},{"type":"text","value":" parameters. Typically, it's fairly safe to assume that the current fair market price is around what the current reserve ratio is for a pair (because of arbitrage). So, if a user wants to add 1 ETH to a pool, and the current DAI/WETH ratio of the pool is 200/1, it's reasonable to calculate that 200 DAI must be sent along with the ETH, which is an implicit commitment to the price of 200 DAI/1 WETH. However, it's important to note that this must be calculated ","position":{"start":{"line":10,"column":128,"offset":1342},"end":{"line":10,"column":590,"offset":1804},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"before the transaction is submitted","position":{"start":{"line":10,"column":591,"offset":1805},"end":{"line":10,"column":626,"offset":1840},"indent":[]}}],"position":{"start":{"line":10,"column":590,"offset":1804},"end":{"line":10,"column":627,"offset":1841},"indent":[]}},{"type":"text","value":". It is ","position":{"start":{"line":10,"column":627,"offset":1841},"end":{"line":10,"column":635,"offset":1849},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"not safe","position":{"start":{"line":10,"column":636,"offset":1850},"end":{"line":10,"column":644,"offset":1858},"indent":[]}}],"position":{"start":{"line":10,"column":635,"offset":1849},"end":{"line":10,"column":645,"offset":1859},"indent":[]}},{"type":"text","value":" to look up the reserve ratio from within a transaction and rely on it as a price belief, as this ratio can be cheaply manipulated to your detriment.","position":{"start":{"line":10,"column":645,"offset":1859},"end":{"line":10,"column":794,"offset":2008},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":1215},"end":{"line":10,"column":794,"offset":2008},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"However, it is still possible to submit a transaction which encodes a belief about the price which ends up being wrong because of a larger change in the true market price before the transaction is confirmed. For that reason, it's necessary to pass an additional set of parameters which encode the caller's tolerance to price changes. These ","position":{"start":{"line":12,"column":1,"offset":2012},"end":{"line":12,"column":341,"offset":2352},"indent":[]}},{"type":"inlineCode","value":"amount*Min","position":{"start":{"line":12,"column":341,"offset":2352},"end":{"line":12,"column":353,"offset":2364},"indent":[]}},{"type":"text","value":" parameters should typically be set to percentages of the calculated desired price. So, at a 1% tolerance level, if our user sends a transaction with 1 ETH and 200 DAI, ","position":{"start":{"line":12,"column":353,"offset":2364},"end":{"line":12,"column":522,"offset":2533},"indent":[]}},{"type":"inlineCode","value":"amountETHMin","position":{"start":{"line":12,"column":522,"offset":2533},"end":{"line":12,"column":536,"offset":2547},"indent":[]}},{"type":"text","value":" should be set to e.g. .99 ETH, and ","position":{"start":{"line":12,"column":536,"offset":2547},"end":{"line":12,"column":572,"offset":2583},"indent":[]}},{"type":"inlineCode","value":"amountTokenMin","position":{"start":{"line":12,"column":572,"offset":2583},"end":{"line":12,"column":588,"offset":2599},"indent":[]}},{"type":"text","value":" should be set to 198 DAI. This means that, at worst, liquidity will be added at a rate between 198 DAI/1 ETH and 202.02 DAI/1 ETH (200 DAI/.99 ETH).","position":{"start":{"line":12,"column":588,"offset":2599},"end":{"line":12,"column":737,"offset":2748},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":2012},"end":{"line":12,"column":737,"offset":2748},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Once the price calculations have been made, it's important to ensure that your contract a) controls at least as many tokens/ETH as were passed as ","position":{"start":{"line":14,"column":1,"offset":2752},"end":{"line":14,"column":147,"offset":2898},"indent":[]}},{"type":"inlineCode","value":"amount*Desired","position":{"start":{"line":14,"column":147,"offset":2898},"end":{"line":14,"column":163,"offset":2914},"indent":[]}},{"type":"text","value":" parameters, and b) has granted approval to the router to withdraw this many tokens.","position":{"start":{"line":14,"column":163,"offset":2914},"end":{"line":14,"column":247,"offset":2998},"indent":[]}}],"position":{"start":{"line":14,"column":1,"offset":2752},"end":{"line":14,"column":247,"offset":2998},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"Providing Liquidity\",\"tags\":\"smart contract integration, developer-guides, documentation\"}","position":{"start":{"line":17,"column":1,"offset":3002},"end":{"line":17,"column":129,"offset":3130},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":17,"column":129,"offset":3130}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Providing Liquidity\",\n  \"tags\": \"smart contract integration, developer-guides, documentation\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Link = makeShortcode(\"Link\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"introduction\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#introduction\",\n    \"aria-label\": \"introduction permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Introduction\"), mdx(\"p\", null, \"When providing liquidity from a smart contract, the most important thing to keep in mind is that tokens deposited into a pool at any rate other than the current reserve ratio \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"are vulnerable to being arbitraged\"), \". As an example, if the ratio of x:y in a pair is 10:2 (i.e. the price is 5), and someone naively adds liquidity at 5:2 (a price of 2.5), the contract will simply accept all tokens (changing the price to 3.75 and opening up the market to arbitrage), but only issue pool tokens entitling the sender to the amount of assets sent at the proper ratio, in this case 5:1. To avoid donating to arbitrageurs, it is imperative to add liquidity at the current price. Luckily, it\\u2019s easy to ensure that this condition is met!\"), mdx(\"h1\", {\n    \"id\": \"using-the-router\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#using-the-router\",\n    \"aria-label\": \"using the router permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Using the Router\"), mdx(\"p\", null, \"The easiest way to safely add liquidity to a pool is to use the \", mdx(Link, {\n    to: \"/docs/v1/smart-contracts/router02\",\n    mdxType: \"Link\"\n  }, \"router\"), \", which provides simple methods to safely add liquidity to a pool. If the liquidity is to be added to an ERC-20/ERC-20 pair, use \", mdx(Link, {\n    to: \"/docs/v1/smart-contracts/router02/#addliquidity\",\n    mdxType: \"Link\"\n  }, \"addLiquidity\"), \". If WETH is involved, use \", mdx(Link, {\n    to: \"/docs/v1/smart-contracts/router02/#addliquidityeth\",\n    mdxType: \"Link\"\n  }, \"addLiquidityETH\"), \".\"), mdx(\"p\", null, \"These methods both require the caller to commit to a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"belief about the current price\"), \", which is encoded in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"amount*Desired\"), \" parameters. Typically, it\\u2019s fairly safe to assume that the current fair market price is around what the current reserve ratio is for a pair (because of arbitrage). So, if a user wants to add 1 ETH to a pool, and the current DAI/WETH ratio of the pool is 200/1, it\\u2019s reasonable to calculate that 200 DAI must be sent along with the ETH, which is an implicit commitment to the price of 200 DAI/1 WETH. However, it\\u2019s important to note that this must be calculated \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"before the transaction is submitted\"), \". It is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not safe\"), \" to look up the reserve ratio from within a transaction and rely on it as a price belief, as this ratio can be cheaply manipulated to your detriment.\"), mdx(\"p\", null, \"However, it is still possible to submit a transaction which encodes a belief about the price which ends up being wrong because of a larger change in the true market price before the transaction is confirmed. For that reason, it\\u2019s necessary to pass an additional set of parameters which encode the caller\\u2019s tolerance to price changes. These \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"amount*Min\"), \" parameters should typically be set to percentages of the calculated desired price. So, at a 1% tolerance level, if our user sends a transaction with 1 ETH and 200 DAI, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"amountETHMin\"), \" should be set to e.g. .99 ETH, and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"amountTokenMin\"), \" should be set to 198 DAI. This means that, at worst, liquidity will be added at a rate between 198 DAI/1 ETH and 202.02 DAI/1 ETH (200 DAI/.99 ETH).\"), mdx(\"p\", null, \"Once the price calculations have been made, it\\u2019s important to ensure that your contract a) controls at least as many tokens/ETH as were passed as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"amount*Desired\"), \" parameters, and b) has granted approval to the router to withdraw this many tokens.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"Providing Liquidity\",\n  \"tags\": \"smart contract integration, developer-guides, documentation\"\n};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n      console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n      return <div {...props}/>\n    };\nconst Link = makeShortcode(\"Link\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1 {...{\n      \"id\": \"introduction\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h1\" {...{\n        \"href\": \"#introduction\",\n        \"aria-label\": \"introduction permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Introduction`}</h1>\n    <p>{`When providing liquidity from a smart contract, the most important thing to keep in mind is that tokens deposited into a pool at any rate other than the current reserve ratio `}<em parentName=\"p\">{`are vulnerable to being arbitraged`}</em>{`. As an example, if the ratio of x:y in a pair is 10:2 (i.e. the price is 5), and someone naively adds liquidity at 5:2 (a price of 2.5), the contract will simply accept all tokens (changing the price to 3.75 and opening up the market to arbitrage), but only issue pool tokens entitling the sender to the amount of assets sent at the proper ratio, in this case 5:1. To avoid donating to arbitrageurs, it is imperative to add liquidity at the current price. Luckily, it’s easy to ensure that this condition is met!`}</p>\n    <h1 {...{\n      \"id\": \"using-the-router\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h1\" {...{\n        \"href\": \"#using-the-router\",\n        \"aria-label\": \"using the router permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Using the Router`}</h1>\n    <p>{`The easiest way to safely add liquidity to a pool is to use the `}<Link to='/docs/v1/smart-contracts/router02' mdxType=\"Link\">{`router`}</Link>{`, which provides simple methods to safely add liquidity to a pool. If the liquidity is to be added to an ERC-20/ERC-20 pair, use `}<Link to='/docs/v1/smart-contracts/router02/#addliquidity' mdxType=\"Link\">{`addLiquidity`}</Link>{`. If WETH is involved, use `}<Link to='/docs/v1/smart-contracts/router02/#addliquidityeth' mdxType=\"Link\">{`addLiquidityETH`}</Link>{`.`}</p>\n    <p>{`These methods both require the caller to commit to a `}<em parentName=\"p\">{`belief about the current price`}</em>{`, which is encoded in the `}<inlineCode parentName=\"p\">{`amount*Desired`}</inlineCode>{` parameters. Typically, it’s fairly safe to assume that the current fair market price is around what the current reserve ratio is for a pair (because of arbitrage). So, if a user wants to add 1 ETH to a pool, and the current DAI/WETH ratio of the pool is 200/1, it’s reasonable to calculate that 200 DAI must be sent along with the ETH, which is an implicit commitment to the price of 200 DAI/1 WETH. However, it’s important to note that this must be calculated `}<em parentName=\"p\">{`before the transaction is submitted`}</em>{`. It is `}<em parentName=\"p\">{`not safe`}</em>{` to look up the reserve ratio from within a transaction and rely on it as a price belief, as this ratio can be cheaply manipulated to your detriment.`}</p>\n    <p>{`However, it is still possible to submit a transaction which encodes a belief about the price which ends up being wrong because of a larger change in the true market price before the transaction is confirmed. For that reason, it’s necessary to pass an additional set of parameters which encode the caller’s tolerance to price changes. These `}<inlineCode parentName=\"p\">{`amount*Min`}</inlineCode>{` parameters should typically be set to percentages of the calculated desired price. So, at a 1% tolerance level, if our user sends a transaction with 1 ETH and 200 DAI, `}<inlineCode parentName=\"p\">{`amountETHMin`}</inlineCode>{` should be set to e.g. .99 ETH, and `}<inlineCode parentName=\"p\">{`amountTokenMin`}</inlineCode>{` should be set to 198 DAI. This means that, at worst, liquidity will be added at a rate between 198 DAI/1 ETH and 202.02 DAI/1 ETH (200 DAI/.99 ETH).`}</p>\n    <p>{`Once the price calculations have been made, it’s important to ensure that your contract a) controls at least as many tokens/ETH as were passed as `}<inlineCode parentName=\"p\">{`amount*Desired`}</inlineCode>{` parameters, and b) has granted approval to the router to withdraw this many tokens.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}