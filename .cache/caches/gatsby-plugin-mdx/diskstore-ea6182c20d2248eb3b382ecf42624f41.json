{"expireTime":9007200872306491000,"key":"gatsby-plugin-mdx-entire-payload-70f5a09dd2d54b0be78e7cc2840c23c0-","val":{"mdast":{"type":"root","children":[{"type":"heading","depth":1,"children":[{"type":"text","value":"How are prices determined?","position":{"start":{"line":2,"column":3,"offset":4},"end":{"line":2,"column":29,"offset":30},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":2},"end":{"line":2,"column":29,"offset":30},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"As we learned in ","position":{"start":{"line":4,"column":1,"offset":34},"end":{"line":4,"column":18,"offset":51},"indent":[]}},{"type":"link","title":null,"url":"/docs/v1/protocol-overview/how-kwikswap-works","children":[{"type":"text","value":"Protocol Overview","position":{"start":{"line":4,"column":19,"offset":52},"end":{"line":4,"column":36,"offset":69},"indent":[]}}],"position":{"start":{"line":4,"column":18,"offset":51},"end":{"line":4,"column":84,"offset":117},"indent":[]}},{"type":"text","value":", each pair on Kwikswap is actually underpinned by a liquidity pool. Liquidity pools are smart contracts that hold balances of two unique tokens and enforces rules around depositing and withdrawing them. The primary rule is the ","position":{"start":{"line":4,"column":84,"offset":117},"end":{"line":4,"column":312,"offset":345},"indent":[]}},{"type":"link","title":null,"url":"/docs/v1/protocol-overview/glossary#constant-product-formula","children":[{"type":"text","value":"constant product formula","position":{"start":{"line":4,"column":313,"offset":346},"end":{"line":4,"column":337,"offset":370},"indent":[]}}],"position":{"start":{"line":4,"column":312,"offset":345},"end":{"line":4,"column":400,"offset":433},"indent":[]}},{"type":"text","value":". When a token is withdrawn (bought), a proportional amount must be deposited (sold) to maintain the constant. The ratio of tokens in the pool, in combination with the constant product formula, ultimately determine the price that a swap executes at.","position":{"start":{"line":4,"column":400,"offset":433},"end":{"line":4,"column":649,"offset":682},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":34},"end":{"line":4,"column":649,"offset":682},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"How Kwikswap handles prices","position":{"start":{"line":6,"column":3,"offset":688},"end":{"line":6,"column":30,"offset":715},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":686},"end":{"line":6,"column":30,"offset":715},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In Kwikswap V0, trades are always executed at the \"best possible\" price, calcuated at execution time. Somewhat confusingly, this calculation is actually accomplished with one of two different formulas, depending on whether the trade specifies an exact ","position":{"start":{"line":8,"column":1,"offset":719},"end":{"line":8,"column":253,"offset":971},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"input","position":{"start":{"line":8,"column":254,"offset":972},"end":{"line":8,"column":259,"offset":977},"indent":[]}}],"position":{"start":{"line":8,"column":253,"offset":971},"end":{"line":8,"column":260,"offset":978},"indent":[]}},{"type":"text","value":" or ","position":{"start":{"line":8,"column":260,"offset":978},"end":{"line":8,"column":264,"offset":982},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"output","position":{"start":{"line":8,"column":265,"offset":983},"end":{"line":8,"column":271,"offset":989},"indent":[]}}],"position":{"start":{"line":8,"column":264,"offset":982},"end":{"line":8,"column":272,"offset":990},"indent":[]}},{"type":"text","value":" amount. Functionally, the difference between these two functions is miniscule, but the very existence of a difference increases conceptual complexity. Initial attempts to support both functions in proved inelegant, and the decision was made to ","position":{"start":{"line":8,"column":272,"offset":990},"end":{"line":8,"column":517,"offset":1235},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"not provide any pricing functions in the core","position":{"start":{"line":8,"column":519,"offset":1237},"end":{"line":8,"column":564,"offset":1282},"indent":[]}}],"position":{"start":{"line":8,"column":517,"offset":1235},"end":{"line":8,"column":566,"offset":1284},"indent":[]}},{"type":"text","value":". Instead, pairs directly check whether the invariant was satisfied (accounting for fees) after every trade. This means that rather than relying on a pricing function to ","position":{"start":{"line":8,"column":566,"offset":1284},"end":{"line":8,"column":736,"offset":1454},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"also","position":{"start":{"line":8,"column":737,"offset":1455},"end":{"line":8,"column":741,"offset":1459},"indent":[]}}],"position":{"start":{"line":8,"column":736,"offset":1454},"end":{"line":8,"column":742,"offset":1460},"indent":[]}},{"type":"text","value":" enforce the invariant, pairs simply and transparently ensure their own safety, a nice separation of concerns. One downstream benefit is that pairs will more naturally support other flavors of trades which may emerge, (e.g. trading to a specific price at execution time).","position":{"start":{"line":8,"column":742,"offset":1460},"end":{"line":8,"column":1013,"offset":1731},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":719},"end":{"line":8,"column":1013,"offset":1731},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"At a high level, in Kwikswap, ","position":{"start":{"line":10,"column":1,"offset":1735},"end":{"line":10,"column":31,"offset":1765},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"trades must be priced in the periphery","position":{"start":{"line":10,"column":32,"offset":1766},"end":{"line":10,"column":70,"offset":1804},"indent":[]}}],"position":{"start":{"line":10,"column":31,"offset":1765},"end":{"line":10,"column":71,"offset":1805},"indent":[]}},{"type":"text","value":". The good news is that the ","position":{"start":{"line":10,"column":71,"offset":1805},"end":{"line":10,"column":99,"offset":1833},"indent":[]}},{"type":"jsx","value":"<Link to='/docs/v1/smart-contracts/library'>","position":{"start":{"line":10,"column":99,"offset":1833},"end":{"line":10,"column":143,"offset":1877},"indent":[]}},{"type":"text","value":"library","position":{"start":{"line":10,"column":143,"offset":1877},"end":{"line":10,"column":150,"offset":1884},"indent":[]}},{"type":"jsx","value":"</Link>","position":{"start":{"line":10,"column":150,"offset":1884},"end":{"line":10,"column":157,"offset":1891},"indent":[]}},{"type":"text","value":" provides a variety of functions designed to make this quite simple, and all swapping functions in the ","position":{"start":{"line":10,"column":157,"offset":1891},"end":{"line":10,"column":260,"offset":1994},"indent":[]}},{"type":"jsx","value":"<Link to='/docs/v1/smart-contracts/library'>","position":{"start":{"line":10,"column":260,"offset":1994},"end":{"line":10,"column":304,"offset":2038},"indent":[]}},{"type":"text","value":"router","position":{"start":{"line":10,"column":304,"offset":2038},"end":{"line":10,"column":310,"offset":2044},"indent":[]}},{"type":"jsx","value":"</Link>","position":{"start":{"line":10,"column":310,"offset":2044},"end":{"line":10,"column":317,"offset":2051},"indent":[]}},{"type":"text","value":" are designed with this in mind.","position":{"start":{"line":10,"column":317,"offset":2051},"end":{"line":10,"column":349,"offset":2083},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":1735},"end":{"line":10,"column":349,"offset":2083},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Pricing Trades","position":{"start":{"line":12,"column":3,"offset":2089},"end":{"line":12,"column":17,"offset":2103},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":2087},"end":{"line":12,"column":17,"offset":2103},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"When swapping tokens on Kwikswap, it's common to want to receive as many output tokens as possible for an ","position":{"start":{"line":14,"column":1,"offset":2107},"end":{"line":14,"column":107,"offset":2213},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"exact input amount","position":{"start":{"line":14,"column":108,"offset":2214},"end":{"line":14,"column":126,"offset":2232},"indent":[]}}],"position":{"start":{"line":14,"column":107,"offset":2213},"end":{"line":14,"column":127,"offset":2233},"indent":[]}},{"type":"text","value":", or to pay as few input tokens as possible for an ","position":{"start":{"line":14,"column":127,"offset":2233},"end":{"line":14,"column":178,"offset":2284},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"exact output amount","position":{"start":{"line":14,"column":179,"offset":2285},"end":{"line":14,"column":198,"offset":2304},"indent":[]}}],"position":{"start":{"line":14,"column":178,"offset":2284},"end":{"line":14,"column":199,"offset":2305},"indent":[]}},{"type":"text","value":". In order to calculate these amounts, a contract must look up the ","position":{"start":{"line":14,"column":199,"offset":2305},"end":{"line":14,"column":266,"offset":2372},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"current reserves","position":{"start":{"line":14,"column":267,"offset":2373},"end":{"line":14,"column":283,"offset":2389},"indent":[]}}],"position":{"start":{"line":14,"column":266,"offset":2372},"end":{"line":14,"column":284,"offset":2390},"indent":[]}},{"type":"text","value":" of a pair, in order to understand what the current price is. However, it is ","position":{"start":{"line":14,"column":284,"offset":2390},"end":{"line":14,"column":361,"offset":2467},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"not safe to perform this lookup and rely on the results without access to an external price","position":{"start":{"line":14,"column":362,"offset":2468},"end":{"line":14,"column":453,"offset":2559},"indent":[]}}],"position":{"start":{"line":14,"column":361,"offset":2467},"end":{"line":14,"column":454,"offset":2560},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":14,"column":454,"offset":2560},"end":{"line":14,"column":455,"offset":2561},"indent":[]}}],"position":{"start":{"line":14,"column":1,"offset":2107},"end":{"line":14,"column":455,"offset":2561},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Say a smart contract naively wants to send 10 DAI to the DAI/WETH pair and receive as much WETH as it can get, given the current reserve ratio. If, when called, the naive smart contract simply looks up the current price and executes the trade, it is ","position":{"start":{"line":16,"column":1,"offset":2565},"end":{"line":16,"column":251,"offset":2815},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"vulnerable to front-running and will likely suffer an economic loss","position":{"start":{"line":16,"column":252,"offset":2816},"end":{"line":16,"column":319,"offset":2883},"indent":[]}}],"position":{"start":{"line":16,"column":251,"offset":2815},"end":{"line":16,"column":320,"offset":2884},"indent":[]}},{"type":"text","value":". To see why, consider a malicious actor who sees this transaction before it is confirmed. They could execute a swap which dramatically changes the DAI/WETH price immediately before the naive swap goes through, wait for the naive swap to execute at a bad rate, and then swap to change the price back to what it was before the naive swap. This attack is fairly cheap and low-risk, and can typically be performed for a profit.","position":{"start":{"line":16,"column":320,"offset":2884},"end":{"line":16,"column":744,"offset":3308},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":2565},"end":{"line":16,"column":744,"offset":3308},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"To prevent these types of attacks, it's vital to submit swaps ","position":{"start":{"line":18,"column":1,"offset":3312},"end":{"line":18,"column":63,"offset":3374},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"that have access to knowledge about the \"fair\" price their swap should execute at","position":{"start":{"line":18,"column":64,"offset":3375},"end":{"line":18,"column":145,"offset":3456},"indent":[]}}],"position":{"start":{"line":18,"column":63,"offset":3374},"end":{"line":18,"column":146,"offset":3457},"indent":[]}},{"type":"text","value":". In other words, swaps need access to an ","position":{"start":{"line":18,"column":146,"offset":3457},"end":{"line":18,"column":188,"offset":3499},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"oracle","position":{"start":{"line":18,"column":189,"offset":3500},"end":{"line":18,"column":195,"offset":3506},"indent":[]}}],"position":{"start":{"line":18,"column":188,"offset":3499},"end":{"line":18,"column":196,"offset":3507},"indent":[]}},{"type":"text","value":", to be sure that the best execution they can get from Kwikswap is close enough to what the oracle considers the \"true\" price. While this may sound complicated, the oracle can be as simple as an ","position":{"start":{"line":18,"column":196,"offset":3507},"end":{"line":18,"column":391,"offset":3702},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"off-chain observation of the current market price of a pair","position":{"start":{"line":18,"column":392,"offset":3703},"end":{"line":18,"column":451,"offset":3762},"indent":[]}}],"position":{"start":{"line":18,"column":391,"offset":3702},"end":{"line":18,"column":452,"offset":3763},"indent":[]}},{"type":"text","value":". Because of arbitrage, it's typically the case that the ratio of the intra-block reserves of a pair is close to the \"true\" market price. So, if a user submits a trade with this knowledge in mind, they can ensure that the losses due to front-running are tightly bounded. This is how, for example, the Kwikswap frontend ensure trade safety. It calculates the optimal input/output amounts given observed intra-block prices, and uses the router to perform the swap, which guarantees the swap will execute at a rate no less that ","position":{"start":{"line":18,"column":452,"offset":3763},"end":{"line":18,"column":977,"offset":4288},"indent":[]}},{"type":"inlineCode","value":"x","position":{"start":{"line":18,"column":977,"offset":4288},"end":{"line":18,"column":980,"offset":4291},"indent":[]}},{"type":"text","value":"% worse than the observed intra-block rate, where ","position":{"start":{"line":18,"column":980,"offset":4291},"end":{"line":18,"column":1030,"offset":4341},"indent":[]}},{"type":"inlineCode","value":"x","position":{"start":{"line":18,"column":1030,"offset":4341},"end":{"line":18,"column":1033,"offset":4344},"indent":[]}},{"type":"text","value":" is a user-specified slippage tolerance (0.5% by default).","position":{"start":{"line":18,"column":1033,"offset":4344},"end":{"line":18,"column":1091,"offset":4402},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":3312},"end":{"line":18,"column":1091,"offset":4402},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"There are, of course, other options for oracles, including ","position":{"start":{"line":20,"column":1,"offset":4406},"end":{"line":20,"column":60,"offset":4465},"indent":[]}},{"type":"jsx","value":"<Link to='/docs/v1/core-concepts/oracles'>","position":{"start":{"line":20,"column":60,"offset":4465},"end":{"line":20,"column":102,"offset":4507},"indent":[]}},{"type":"text","value":"native Kwikswap oracles","position":{"start":{"line":20,"column":102,"offset":4507},"end":{"line":20,"column":125,"offset":4530},"indent":[]}},{"type":"jsx","value":"</Link>","position":{"start":{"line":20,"column":125,"offset":4530},"end":{"line":20,"column":132,"offset":4537},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":20,"column":132,"offset":4537},"end":{"line":20,"column":133,"offset":4538},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":4406},"end":{"line":20,"column":133,"offset":4538},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Exact Input","position":{"start":{"line":22,"column":4,"offset":4545},"end":{"line":22,"column":15,"offset":4556},"indent":[]}}],"position":{"start":{"line":22,"column":1,"offset":4542},"end":{"line":22,"column":15,"offset":4556},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"If you'd like to send an exact amount of input tokens in exchange for as many output tokens as possible, you'll want to use ","position":{"start":{"line":24,"column":1,"offset":4560},"end":{"line":24,"column":125,"offset":4684},"indent":[]}},{"type":"jsx","value":"<Link to='/docs/v1/smart-contracts/router02/#getamountsout'>","position":{"start":{"line":24,"column":125,"offset":4684},"end":{"line":24,"column":185,"offset":4744},"indent":[]}},{"type":"text","value":"getAmountsOut","position":{"start":{"line":24,"column":185,"offset":4744},"end":{"line":24,"column":198,"offset":4757},"indent":[]}},{"type":"jsx","value":"</Link>","position":{"start":{"line":24,"column":198,"offset":4757},"end":{"line":24,"column":205,"offset":4764},"indent":[]}},{"type":"text","value":". The equivalent SDK function is ","position":{"start":{"line":24,"column":205,"offset":4764},"end":{"line":24,"column":238,"offset":4797},"indent":[]}},{"type":"jsx","value":"<Link to='/docs/v1/SDK/pair/#getoutputamount'>","position":{"start":{"line":24,"column":238,"offset":4797},"end":{"line":24,"column":284,"offset":4843},"indent":[]}},{"type":"text","value":"getOutputAmount","position":{"start":{"line":24,"column":284,"offset":4843},"end":{"line":24,"column":299,"offset":4858},"indent":[]}},{"type":"jsx","value":"</Link>","position":{"start":{"line":24,"column":299,"offset":4858},"end":{"line":24,"column":306,"offset":4865},"indent":[]}},{"type":"text","value":", or ","position":{"start":{"line":24,"column":306,"offset":4865},"end":{"line":24,"column":311,"offset":4870},"indent":[]}},{"type":"jsx","value":"<Link to='/docs/v1/SDK/trade/#minimumamountout-since-204'>","position":{"start":{"line":24,"column":311,"offset":4870},"end":{"line":24,"column":369,"offset":4928},"indent":[]}},{"type":"text","value":"minimumAmountOut","position":{"start":{"line":24,"column":369,"offset":4928},"end":{"line":24,"column":385,"offset":4944},"indent":[]}},{"type":"jsx","value":"</Link>","position":{"start":{"line":24,"column":385,"offset":4944},"end":{"line":24,"column":392,"offset":4951},"indent":[]}},{"type":"text","value":" for slippage calculations.","position":{"start":{"line":24,"column":392,"offset":4951},"end":{"line":24,"column":419,"offset":4978},"indent":[]}}],"position":{"start":{"line":24,"column":1,"offset":4560},"end":{"line":24,"column":419,"offset":4978},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Exact Output","position":{"start":{"line":26,"column":4,"offset":4985},"end":{"line":26,"column":16,"offset":4997},"indent":[]}}],"position":{"start":{"line":26,"column":1,"offset":4982},"end":{"line":26,"column":16,"offset":4997},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"If you'd like to receive an exact amount of output tokens for as few input tokens as possible, you'll want to use ","position":{"start":{"line":28,"column":1,"offset":5001},"end":{"line":28,"column":115,"offset":5115},"indent":[]}},{"type":"jsx","value":"<Link to='/docs/v1/smart-contracts/router02/#getamountsin'>","position":{"start":{"line":28,"column":115,"offset":5115},"end":{"line":28,"column":174,"offset":5174},"indent":[]}},{"type":"text","value":"getAmountsIn","position":{"start":{"line":28,"column":174,"offset":5174},"end":{"line":28,"column":186,"offset":5186},"indent":[]}},{"type":"jsx","value":"</Link>","position":{"start":{"line":28,"column":186,"offset":5186},"end":{"line":28,"column":193,"offset":5193},"indent":[]}},{"type":"text","value":". The equivalent SDK function is ","position":{"start":{"line":28,"column":193,"offset":5193},"end":{"line":28,"column":226,"offset":5226},"indent":[]}},{"type":"jsx","value":"<Link to='/docs/v1/SDK/pair/#getinputamount'>","position":{"start":{"line":28,"column":226,"offset":5226},"end":{"line":28,"column":271,"offset":5271},"indent":[]}},{"type":"text","value":"getInputAmount","position":{"start":{"line":28,"column":271,"offset":5271},"end":{"line":28,"column":285,"offset":5285},"indent":[]}},{"type":"jsx","value":"</Link>","position":{"start":{"line":28,"column":285,"offset":5285},"end":{"line":28,"column":292,"offset":5292},"indent":[]}},{"type":"text","value":", or ","position":{"start":{"line":28,"column":292,"offset":5292},"end":{"line":28,"column":297,"offset":5297},"indent":[]}},{"type":"jsx","value":"<Link to='/docs/v1/SDK/trade/#maximumamountin-since-204'>","position":{"start":{"line":28,"column":297,"offset":5297},"end":{"line":28,"column":354,"offset":5354},"indent":[]}},{"type":"text","value":"maximumAmountIn","position":{"start":{"line":28,"column":354,"offset":5354},"end":{"line":28,"column":369,"offset":5369},"indent":[]}},{"type":"jsx","value":"</Link>","position":{"start":{"line":28,"column":369,"offset":5369},"end":{"line":28,"column":376,"offset":5376},"indent":[]}},{"type":"text","value":" for slippage calculations.","position":{"start":{"line":28,"column":376,"offset":5376},"end":{"line":28,"column":403,"offset":5403},"indent":[]}}],"position":{"start":{"line":28,"column":1,"offset":5001},"end":{"line":28,"column":403,"offset":5403},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Swap to Price","position":{"start":{"line":30,"column":4,"offset":5410},"end":{"line":30,"column":17,"offset":5423},"indent":[]}}],"position":{"start":{"line":30,"column":1,"offset":5407},"end":{"line":30,"column":17,"offset":5423},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"For this more advanced use case, see ","position":{"start":{"line":32,"column":1,"offset":5427},"end":{"line":32,"column":38,"offset":5464},"indent":[]}},{"type":"jsx","value":"<Github href=\"https://github.com/Kwikswap/Kwikswap-V1-Periphery/blob/master/contracts/examples/ExampleSwapToPrice.sol\">","position":{"start":{"line":32,"column":38,"offset":5464},"end":{"line":32,"column":157,"offset":5583},"indent":[]}},{"type":"text","value":"ExampleSwapToPrice.sol","position":{"start":{"line":32,"column":157,"offset":5583},"end":{"line":32,"column":179,"offset":5605},"indent":[]}},{"type":"jsx","value":"</Github>","position":{"start":{"line":32,"column":179,"offset":5605},"end":{"line":32,"column":188,"offset":5614},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":32,"column":188,"offset":5614},"end":{"line":32,"column":189,"offset":5615},"indent":[]}}],"position":{"start":{"line":32,"column":1,"offset":5427},"end":{"line":32,"column":189,"offset":5615},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"Pricing\",\"tags\":\"swaps, documentation\"}","position":{"start":{"line":35,"column":1,"offset":5619},"end":{"line":35,"column":78,"offset":5696},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":35,"column":78,"offset":5696}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Pricing\",\n  \"tags\": \"swaps, documentation\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Link = makeShortcode(\"Link\");\nvar Github = makeShortcode(\"Github\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-are-prices-determined\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#how-are-prices-determined\",\n    \"aria-label\": \"how are prices determined permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"How are prices determined?\"), mdx(\"p\", null, \"As we learned in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/docs/v1/protocol-overview/how-kwikswap-works\"\n  }, \"Protocol Overview\"), \", each pair on Kwikswap is actually underpinned by a liquidity pool. Liquidity pools are smart contracts that hold balances of two unique tokens and enforces rules around depositing and withdrawing them. The primary rule is the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/docs/v1/protocol-overview/glossary#constant-product-formula\"\n  }, \"constant product formula\"), \". When a token is withdrawn (bought), a proportional amount must be deposited (sold) to maintain the constant. The ratio of tokens in the pool, in combination with the constant product formula, ultimately determine the price that a swap executes at.\"), mdx(\"h1\", {\n    \"id\": \"how-kwikswap-handles-prices\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#how-kwikswap-handles-prices\",\n    \"aria-label\": \"how kwikswap handles prices permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"How Kwikswap handles prices\"), mdx(\"p\", null, \"In Kwikswap V0, trades are always executed at the \\u201Cbest possible\\u201D price, calcuated at execution time. Somewhat confusingly, this calculation is actually accomplished with one of two different formulas, depending on whether the trade specifies an exact \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"input\"), \" or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"output\"), \" amount. Functionally, the difference between these two functions is miniscule, but the very existence of a difference increases conceptual complexity. Initial attempts to support both functions in proved inelegant, and the decision was made to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"not provide any pricing functions in the core\"), \". Instead, pairs directly check whether the invariant was satisfied (accounting for fees) after every trade. This means that rather than relying on a pricing function to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"also\"), \" enforce the invariant, pairs simply and transparently ensure their own safety, a nice separation of concerns. One downstream benefit is that pairs will more naturally support other flavors of trades which may emerge, (e.g. trading to a specific price at execution time).\"), mdx(\"p\", null, \"At a high level, in Kwikswap, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"trades must be priced in the periphery\"), \". The good news is that the \", mdx(Link, {\n    to: \"/docs/v1/smart-contracts/library\",\n    mdxType: \"Link\"\n  }, \"library\"), \" provides a variety of functions designed to make this quite simple, and all swapping functions in the \", mdx(Link, {\n    to: \"/docs/v1/smart-contracts/library\",\n    mdxType: \"Link\"\n  }, \"router\"), \" are designed with this in mind.\"), mdx(\"h1\", {\n    \"id\": \"pricing-trades\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#pricing-trades\",\n    \"aria-label\": \"pricing trades permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Pricing Trades\"), mdx(\"p\", null, \"When swapping tokens on Kwikswap, it\\u2019s common to want to receive as many output tokens as possible for an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"exact input amount\"), \", or to pay as few input tokens as possible for an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"exact output amount\"), \". In order to calculate these amounts, a contract must look up the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"current reserves\"), \" of a pair, in order to understand what the current price is. However, it is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not safe to perform this lookup and rely on the results without access to an external price\"), \".\"), mdx(\"p\", null, \"Say a smart contract naively wants to send 10 DAI to the DAI/WETH pair and receive as much WETH as it can get, given the current reserve ratio. If, when called, the naive smart contract simply looks up the current price and executes the trade, it is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"vulnerable to front-running and will likely suffer an economic loss\"), \". To see why, consider a malicious actor who sees this transaction before it is confirmed. They could execute a swap which dramatically changes the DAI/WETH price immediately before the naive swap goes through, wait for the naive swap to execute at a bad rate, and then swap to change the price back to what it was before the naive swap. This attack is fairly cheap and low-risk, and can typically be performed for a profit.\"), mdx(\"p\", null, \"To prevent these types of attacks, it\\u2019s vital to submit swaps \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"that have access to knowledge about the \\u201Cfair\\u201D price their swap should execute at\"), \". In other words, swaps need access to an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"oracle\"), \", to be sure that the best execution they can get from Kwikswap is close enough to what the oracle considers the \\u201Ctrue\\u201D price. While this may sound complicated, the oracle can be as simple as an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"off-chain observation of the current market price of a pair\"), \". Because of arbitrage, it\\u2019s typically the case that the ratio of the intra-block reserves of a pair is close to the \\u201Ctrue\\u201D market price. So, if a user submits a trade with this knowledge in mind, they can ensure that the losses due to front-running are tightly bounded. This is how, for example, the Kwikswap frontend ensure trade safety. It calculates the optimal input/output amounts given observed intra-block prices, and uses the router to perform the swap, which guarantees the swap will execute at a rate no less that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \"% worse than the observed intra-block rate, where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" is a user-specified slippage tolerance (0.5% by default).\"), mdx(\"p\", null, \"There are, of course, other options for oracles, including \", mdx(Link, {\n    to: \"/docs/v1/core-concepts/oracles\",\n    mdxType: \"Link\"\n  }, \"native Kwikswap oracles\"), \".\"), mdx(\"h2\", {\n    \"id\": \"exact-input\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#exact-input\",\n    \"aria-label\": \"exact input permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Exact Input\"), mdx(\"p\", null, \"If you\\u2019d like to send an exact amount of input tokens in exchange for as many output tokens as possible, you\\u2019ll want to use \", mdx(Link, {\n    to: \"/docs/v1/smart-contracts/router02/#getamountsout\",\n    mdxType: \"Link\"\n  }, \"getAmountsOut\"), \". The equivalent SDK function is \", mdx(Link, {\n    to: \"/docs/v1/SDK/pair/#getoutputamount\",\n    mdxType: \"Link\"\n  }, \"getOutputAmount\"), \", or \", mdx(Link, {\n    to: \"/docs/v1/SDK/trade/#minimumamountout-since-204\",\n    mdxType: \"Link\"\n  }, \"minimumAmountOut\"), \" for slippage calculations.\"), mdx(\"h2\", {\n    \"id\": \"exact-output\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#exact-output\",\n    \"aria-label\": \"exact output permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Exact Output\"), mdx(\"p\", null, \"If you\\u2019d like to receive an exact amount of output tokens for as few input tokens as possible, you\\u2019ll want to use \", mdx(Link, {\n    to: \"/docs/v1/smart-contracts/router02/#getamountsin\",\n    mdxType: \"Link\"\n  }, \"getAmountsIn\"), \". The equivalent SDK function is \", mdx(Link, {\n    to: \"/docs/v1/SDK/pair/#getinputamount\",\n    mdxType: \"Link\"\n  }, \"getInputAmount\"), \", or \", mdx(Link, {\n    to: \"/docs/v1/SDK/trade/#maximumamountin-since-204\",\n    mdxType: \"Link\"\n  }, \"maximumAmountIn\"), \" for slippage calculations.\"), mdx(\"h2\", {\n    \"id\": \"swap-to-price\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#swap-to-price\",\n    \"aria-label\": \"swap to price permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Swap to Price\"), mdx(\"p\", null, \"For this more advanced use case, see \", mdx(Github, {\n    href: \"https://github.com/Kwikswap/Kwikswap-V1-Periphery/blob/master/contracts/examples/ExampleSwapToPrice.sol\",\n    mdxType: \"Github\"\n  }, \"ExampleSwapToPrice.sol\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"Pricing\",\n  \"tags\": \"swaps, documentation\"\n};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n      console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n      return <div {...props}/>\n    };\nconst Link = makeShortcode(\"Link\");\nconst Github = makeShortcode(\"Github\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1 {...{\n      \"id\": \"how-are-prices-determined\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h1\" {...{\n        \"href\": \"#how-are-prices-determined\",\n        \"aria-label\": \"how are prices determined permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`How are prices determined?`}</h1>\n    <p>{`As we learned in `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/v1/protocol-overview/how-kwikswap-works\"\n      }}>{`Protocol Overview`}</a>{`, each pair on Kwikswap is actually underpinned by a liquidity pool. Liquidity pools are smart contracts that hold balances of two unique tokens and enforces rules around depositing and withdrawing them. The primary rule is the `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/v1/protocol-overview/glossary#constant-product-formula\"\n      }}>{`constant product formula`}</a>{`. When a token is withdrawn (bought), a proportional amount must be deposited (sold) to maintain the constant. The ratio of tokens in the pool, in combination with the constant product formula, ultimately determine the price that a swap executes at.`}</p>\n    <h1 {...{\n      \"id\": \"how-kwikswap-handles-prices\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h1\" {...{\n        \"href\": \"#how-kwikswap-handles-prices\",\n        \"aria-label\": \"how kwikswap handles prices permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`How Kwikswap handles prices`}</h1>\n    <p>{`In Kwikswap V0, trades are always executed at the “best possible” price, calcuated at execution time. Somewhat confusingly, this calculation is actually accomplished with one of two different formulas, depending on whether the trade specifies an exact `}<em parentName=\"p\">{`input`}</em>{` or `}<em parentName=\"p\">{`output`}</em>{` amount. Functionally, the difference between these two functions is miniscule, but the very existence of a difference increases conceptual complexity. Initial attempts to support both functions in proved inelegant, and the decision was made to `}<strong parentName=\"p\">{`not provide any pricing functions in the core`}</strong>{`. Instead, pairs directly check whether the invariant was satisfied (accounting for fees) after every trade. This means that rather than relying on a pricing function to `}<em parentName=\"p\">{`also`}</em>{` enforce the invariant, pairs simply and transparently ensure their own safety, a nice separation of concerns. One downstream benefit is that pairs will more naturally support other flavors of trades which may emerge, (e.g. trading to a specific price at execution time).`}</p>\n    <p>{`At a high level, in Kwikswap, `}<em parentName=\"p\">{`trades must be priced in the periphery`}</em>{`. The good news is that the `}<Link to='/docs/v1/smart-contracts/library' mdxType=\"Link\">{`library`}</Link>{` provides a variety of functions designed to make this quite simple, and all swapping functions in the `}<Link to='/docs/v1/smart-contracts/library' mdxType=\"Link\">{`router`}</Link>{` are designed with this in mind.`}</p>\n    <h1 {...{\n      \"id\": \"pricing-trades\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h1\" {...{\n        \"href\": \"#pricing-trades\",\n        \"aria-label\": \"pricing trades permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Pricing Trades`}</h1>\n    <p>{`When swapping tokens on Kwikswap, it’s common to want to receive as many output tokens as possible for an `}<em parentName=\"p\">{`exact input amount`}</em>{`, or to pay as few input tokens as possible for an `}<em parentName=\"p\">{`exact output amount`}</em>{`. In order to calculate these amounts, a contract must look up the `}<em parentName=\"p\">{`current reserves`}</em>{` of a pair, in order to understand what the current price is. However, it is `}<em parentName=\"p\">{`not safe to perform this lookup and rely on the results without access to an external price`}</em>{`.`}</p>\n    <p>{`Say a smart contract naively wants to send 10 DAI to the DAI/WETH pair and receive as much WETH as it can get, given the current reserve ratio. If, when called, the naive smart contract simply looks up the current price and executes the trade, it is `}<em parentName=\"p\">{`vulnerable to front-running and will likely suffer an economic loss`}</em>{`. To see why, consider a malicious actor who sees this transaction before it is confirmed. They could execute a swap which dramatically changes the DAI/WETH price immediately before the naive swap goes through, wait for the naive swap to execute at a bad rate, and then swap to change the price back to what it was before the naive swap. This attack is fairly cheap and low-risk, and can typically be performed for a profit.`}</p>\n    <p>{`To prevent these types of attacks, it’s vital to submit swaps `}<em parentName=\"p\">{`that have access to knowledge about the “fair” price their swap should execute at`}</em>{`. In other words, swaps need access to an `}<em parentName=\"p\">{`oracle`}</em>{`, to be sure that the best execution they can get from Kwikswap is close enough to what the oracle considers the “true” price. While this may sound complicated, the oracle can be as simple as an `}<em parentName=\"p\">{`off-chain observation of the current market price of a pair`}</em>{`. Because of arbitrage, it’s typically the case that the ratio of the intra-block reserves of a pair is close to the “true” market price. So, if a user submits a trade with this knowledge in mind, they can ensure that the losses due to front-running are tightly bounded. This is how, for example, the Kwikswap frontend ensure trade safety. It calculates the optimal input/output amounts given observed intra-block prices, and uses the router to perform the swap, which guarantees the swap will execute at a rate no less that `}<inlineCode parentName=\"p\">{`x`}</inlineCode>{`% worse than the observed intra-block rate, where `}<inlineCode parentName=\"p\">{`x`}</inlineCode>{` is a user-specified slippage tolerance (0.5% by default).`}</p>\n    <p>{`There are, of course, other options for oracles, including `}<Link to='/docs/v1/core-concepts/oracles' mdxType=\"Link\">{`native Kwikswap oracles`}</Link>{`.`}</p>\n    <h2 {...{\n      \"id\": \"exact-input\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h2\" {...{\n        \"href\": \"#exact-input\",\n        \"aria-label\": \"exact input permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Exact Input`}</h2>\n    <p>{`If you’d like to send an exact amount of input tokens in exchange for as many output tokens as possible, you’ll want to use `}<Link to='/docs/v1/smart-contracts/router02/#getamountsout' mdxType=\"Link\">{`getAmountsOut`}</Link>{`. The equivalent SDK function is `}<Link to='/docs/v1/SDK/pair/#getoutputamount' mdxType=\"Link\">{`getOutputAmount`}</Link>{`, or `}<Link to='/docs/v1/SDK/trade/#minimumamountout-since-204' mdxType=\"Link\">{`minimumAmountOut`}</Link>{` for slippage calculations.`}</p>\n    <h2 {...{\n      \"id\": \"exact-output\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h2\" {...{\n        \"href\": \"#exact-output\",\n        \"aria-label\": \"exact output permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Exact Output`}</h2>\n    <p>{`If you’d like to receive an exact amount of output tokens for as few input tokens as possible, you’ll want to use `}<Link to='/docs/v1/smart-contracts/router02/#getamountsin' mdxType=\"Link\">{`getAmountsIn`}</Link>{`. The equivalent SDK function is `}<Link to='/docs/v1/SDK/pair/#getinputamount' mdxType=\"Link\">{`getInputAmount`}</Link>{`, or `}<Link to='/docs/v1/SDK/trade/#maximumamountin-since-204' mdxType=\"Link\">{`maximumAmountIn`}</Link>{` for slippage calculations.`}</p>\n    <h2 {...{\n      \"id\": \"swap-to-price\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h2\" {...{\n        \"href\": \"#swap-to-price\",\n        \"aria-label\": \"swap to price permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Swap to Price`}</h2>\n    <p>{`For this more advanced use case, see `}<Github href=\"https://github.com/Kwikswap/Kwikswap-V1-Periphery/blob/master/contracts/examples/ExampleSwapToPrice.sol\" mdxType=\"Github\">{`ExampleSwapToPrice.sol`}</Github>{`.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}