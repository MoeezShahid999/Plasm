{"expireTime":9007200872306489000,"key":"gatsby-plugin-mdx-entire-payload-d7fa4cdd70ff863ed39ca26bedbeab21-","val":{"mdast":{"type":"root","children":[{"type":"heading","depth":1,"children":[{"type":"text","value":"Introduction","position":{"start":{"line":4,"column":3,"offset":8},"end":{"line":4,"column":15,"offset":20},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":6},"end":{"line":4,"column":15,"offset":20},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Swapping is a kind of process in which, A user picks an input token and get an output token. They specify an input amount, and the Kwikswap protocol automatically calculates how much of the output tokens user will receive. They then execute the swap by clicking the \"Swap\" button, and immediately user receives the output token in the wallet.","position":{"start":{"line":6,"column":1,"offset":24},"end":{"line":6,"column":343,"offset":366},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":24},"end":{"line":6,"column":343,"offset":366},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Swapping the ERC-20 Token is quite easy in Kwikswap Protocol.","position":{"start":{"line":8,"column":1,"offset":370},"end":{"line":8,"column":62,"offset":431},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":370},"end":{"line":8,"column":62,"offset":431},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Kwikswap protocol is a decentralized trading platform. Kwikswap does not use an order book to represent liquidity or determine prices. Kwikswap uses an automated market maker mechanism to provide instant feedback on rates and slippage.","position":{"start":{"line":10,"column":1,"offset":435},"end":{"line":10,"column":236,"offset":670},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":435},"end":{"line":10,"column":236,"offset":670},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In this guide, we’ll look at what happens during a swap at the Kwikswap protocol level to gain a deeper understanding of how Kwikswap works.","position":{"start":{"line":12,"column":1,"offset":674},"end":{"line":12,"column":141,"offset":814},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":674},"end":{"line":12,"column":141,"offset":814},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This rule is the ","position":{"start":{"line":14,"column":1,"offset":818},"end":{"line":14,"column":18,"offset":835},"indent":[]}},{"type":"link","title":null,"url":"/docs/v1/protocol-overview/glossary#constant-product-formula","children":[{"type":"text","value":"constant product formula","position":{"start":{"line":14,"column":19,"offset":836},"end":{"line":14,"column":43,"offset":860},"indent":[]}}],"position":{"start":{"line":14,"column":18,"offset":835},"end":{"line":14,"column":106,"offset":923},"indent":[]}},{"type":"text","value":". When either token is withdrawn (purchased), a proportional amount of the other must be deposited (sold), to maintain the constant.","position":{"start":{"line":14,"column":106,"offset":923},"end":{"line":14,"column":238,"offset":1055},"indent":[]}}],"position":{"start":{"line":14,"column":1,"offset":818},"end":{"line":14,"column":238,"offset":1055},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"As we learned in ","position":{"start":{"line":16,"column":1,"offset":1059},"end":{"line":16,"column":18,"offset":1076},"indent":[]}},{"type":"link","title":null,"url":"/docs/v1/protocol-overview/how-kwikswap-works","children":[{"type":"text","value":"Protocol Overview","position":{"start":{"line":16,"column":19,"offset":1077},"end":{"line":16,"column":36,"offset":1094},"indent":[]}}],"position":{"start":{"line":16,"column":18,"offset":1076},"end":{"line":16,"column":84,"offset":1142},"indent":[]}},{"type":"text","value":", each pair on Kwikswap is actually underpinned by a liquidity pool. Smart contracts are used to maintain the Liquidity Pools of different Tokens.","position":{"start":{"line":16,"column":84,"offset":1142},"end":{"line":16,"column":230,"offset":1288},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":1059},"end":{"line":16,"column":230,"offset":1288},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Anatomy of a swap","position":{"start":{"line":18,"column":4,"offset":1295},"end":{"line":18,"column":21,"offset":1312},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":1292},"end":{"line":18,"column":21,"offset":1312},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In Kwikswap, all the Swaps are get done by calling the single function of ","position":{"start":{"line":20,"column":1,"offset":1316},"end":{"line":20,"column":75,"offset":1390},"indent":[]}},{"type":"inlineCode","value":"swap","position":{"start":{"line":20,"column":75,"offset":1390},"end":{"line":20,"column":81,"offset":1396},"indent":[]}},{"type":"text","value":":","position":{"start":{"line":20,"column":81,"offset":1396},"end":{"line":20,"column":82,"offset":1397},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":1316},"end":{"line":20,"column":82,"offset":1397},"indent":[]}},{"type":"code","lang":"solidity","meta":null,"value":"function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data);","position":{"start":{"line":22,"column":1,"offset":1401},"end":{"line":24,"column":4,"offset":1500},"indent":[1,1]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Receiving tokens","position":{"start":{"line":26,"column":3,"offset":1506},"end":{"line":26,"column":19,"offset":1522},"indent":[]}}],"position":{"start":{"line":26,"column":1,"offset":1504},"end":{"line":26,"column":19,"offset":1522},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"As is probably clear from the function signature, Kwikswap requires ","position":{"start":{"line":28,"column":1,"offset":1526},"end":{"line":28,"column":69,"offset":1594},"indent":[]}},{"type":"inlineCode","value":"swap","position":{"start":{"line":28,"column":69,"offset":1594},"end":{"line":28,"column":75,"offset":1600},"indent":[]}},{"type":"text","value":" callers to ","position":{"start":{"line":28,"column":75,"offset":1600},"end":{"line":28,"column":87,"offset":1612},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"specify how many output tokens they would like to receive","position":{"start":{"line":28,"column":88,"offset":1613},"end":{"line":28,"column":145,"offset":1670},"indent":[]}}],"position":{"start":{"line":28,"column":87,"offset":1612},"end":{"line":28,"column":146,"offset":1671},"indent":[]}},{"type":"text","value":" via the ","position":{"start":{"line":28,"column":146,"offset":1671},"end":{"line":28,"column":155,"offset":1680},"indent":[]}},{"type":"inlineCode","value":"amount{0,1}Out","position":{"start":{"line":28,"column":155,"offset":1680},"end":{"line":28,"column":171,"offset":1696},"indent":[]}},{"type":"text","value":" parameters, which correspond to the desired amount of ","position":{"start":{"line":28,"column":171,"offset":1696},"end":{"line":28,"column":226,"offset":1751},"indent":[]}},{"type":"inlineCode","value":"token{0,1}","position":{"start":{"line":28,"column":226,"offset":1751},"end":{"line":28,"column":238,"offset":1763},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":28,"column":238,"offset":1763},"end":{"line":28,"column":239,"offset":1764},"indent":[]}}],"position":{"start":{"line":28,"column":1,"offset":1526},"end":{"line":28,"column":239,"offset":1764},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Sending Tokens","position":{"start":{"line":30,"column":3,"offset":1770},"end":{"line":30,"column":17,"offset":1784},"indent":[]}}],"position":{"start":{"line":30,"column":1,"offset":1768},"end":{"line":30,"column":17,"offset":1784},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"What’s not as clear is how Kwikswap ","position":{"start":{"line":32,"column":1,"offset":1788},"end":{"line":32,"column":37,"offset":1824},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"receives","position":{"start":{"line":32,"column":38,"offset":1825},"end":{"line":32,"column":46,"offset":1833},"indent":[]}}],"position":{"start":{"line":32,"column":37,"offset":1824},"end":{"line":32,"column":47,"offset":1834},"indent":[]}},{"type":"text","value":" tokens as payment for the swap. Typically, smart contracts which need tokens to perform some functionality require callers to first make an approval on the token contract, then call a function that in turn calls transferFrom on the token contract. This is ","position":{"start":{"line":32,"column":47,"offset":1834},"end":{"line":32,"column":304,"offset":2091},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"not","position":{"start":{"line":32,"column":305,"offset":2092},"end":{"line":32,"column":308,"offset":2095},"indent":[]}}],"position":{"start":{"line":32,"column":304,"offset":2091},"end":{"line":32,"column":309,"offset":2096},"indent":[]}},{"type":"text","value":" how pairs accept tokens. Instead, pairs check their token balances at the ","position":{"start":{"line":32,"column":309,"offset":2096},"end":{"line":32,"column":384,"offset":2171},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"end","position":{"start":{"line":32,"column":385,"offset":2172},"end":{"line":32,"column":388,"offset":2175},"indent":[]}}],"position":{"start":{"line":32,"column":384,"offset":2171},"end":{"line":32,"column":389,"offset":2176},"indent":[]}},{"type":"text","value":" of every interaction. Then, at the beginning of the ","position":{"start":{"line":32,"column":389,"offset":2176},"end":{"line":32,"column":442,"offset":2229},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"next","position":{"start":{"line":32,"column":443,"offset":2230},"end":{"line":32,"column":447,"offset":2234},"indent":[]}}],"position":{"start":{"line":32,"column":442,"offset":2229},"end":{"line":32,"column":448,"offset":2235},"indent":[]}},{"type":"text","value":" interaction, current balances are differenced against the stored values to determine the amount of tokens that were sent by the current interactor. See the ","position":{"start":{"line":32,"column":448,"offset":2235},"end":{"line":32,"column":605,"offset":2392},"indent":[]}},{"type":"jsx","value":"<a href='/whitepaper.pdf' rel='noopener noreferrer'>","position":{"start":{"line":32,"column":605,"offset":2392},"end":{"line":32,"column":657,"offset":2444},"indent":[]}},{"type":"text","value":"whitepaper","position":{"start":{"line":32,"column":657,"offset":2444},"end":{"line":32,"column":667,"offset":2454},"indent":[]}},{"type":"jsx","value":"</a>","position":{"start":{"line":32,"column":667,"offset":2454},"end":{"line":32,"column":671,"offset":2458},"indent":[]}},{"type":"text","value":" for a justification of why this is the case.","position":{"start":{"line":32,"column":671,"offset":2458},"end":{"line":32,"column":716,"offset":2503},"indent":[]}}],"position":{"start":{"line":32,"column":1,"offset":1788},"end":{"line":32,"column":716,"offset":2503},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Developer resources","position":{"start":{"line":34,"column":3,"offset":2509},"end":{"line":34,"column":22,"offset":2528},"indent":[]}}],"position":{"start":{"line":34,"column":1,"offset":2507},"end":{"line":34,"column":22,"offset":2528},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"To see how to implement token swaps in a smart contract read ","position":{"start":{"line":36,"column":3,"offset":2534},"end":{"line":36,"column":64,"offset":2595},"indent":[]}},{"type":"link","title":null,"url":"/docs/v1/smart-contract-integration/trading-from-a-smart-contract/","children":[{"type":"text","value":"Trading from a smart contract","position":{"start":{"line":36,"column":65,"offset":2596},"end":{"line":36,"column":94,"offset":2625},"indent":[]}}],"position":{"start":{"line":36,"column":64,"offset":2595},"end":{"line":36,"column":163,"offset":2694},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":36,"column":163,"offset":2694},"end":{"line":36,"column":164,"offset":2695},"indent":[]}}],"position":{"start":{"line":36,"column":3,"offset":2534},"end":{"line":36,"column":164,"offset":2695},"indent":[]}}],"position":{"start":{"line":36,"column":1,"offset":2532},"end":{"line":36,"column":164,"offset":2695},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"To see how to execute a swap from an interface read ","position":{"start":{"line":37,"column":3,"offset":2699},"end":{"line":37,"column":55,"offset":2751},"indent":[]}},{"type":"link","title":null,"url":"/docs/v1/javascript-SDK/trading/","children":[{"type":"text","value":"Trading (SDK)","position":{"start":{"line":37,"column":56,"offset":2752},"end":{"line":37,"column":69,"offset":2765},"indent":[]}}],"position":{"start":{"line":37,"column":55,"offset":2751},"end":{"line":37,"column":104,"offset":2800},"indent":[]}}],"position":{"start":{"line":37,"column":3,"offset":2699},"end":{"line":37,"column":104,"offset":2800},"indent":[]}}],"position":{"start":{"line":37,"column":1,"offset":2697},"end":{"line":37,"column":104,"offset":2800},"indent":[]}}],"position":{"start":{"line":36,"column":1,"offset":2532},"end":{"line":37,"column":104,"offset":2800},"indent":[1]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"Swaps\",\"subtitle\":\"Learn about the core functionality of the kwikswap protocol. Token Swaps.\",\"tags\":\"swaps, documentation\"}","position":{"start":{"line":40,"column":1,"offset":2804},"end":{"line":40,"column":163,"offset":2966},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":40,"column":163,"offset":2966}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Swaps\",\n  \"subtitle\": \"Learn about the core functionality of the kwikswap protocol. Token Swaps.\",\n  \"tags\": \"swaps, documentation\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"introduction\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#introduction\",\n    \"aria-label\": \"introduction permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Introduction\"), mdx(\"p\", null, \"Swapping is a kind of process in which, A user picks an input token and get an output token. They specify an input amount, and the Kwikswap protocol automatically calculates how much of the output tokens user will receive. They then execute the swap by clicking the \\u201CSwap\\u201D button, and immediately user receives the output token in the wallet.\"), mdx(\"p\", null, \"Swapping the ERC-20 Token is quite easy in Kwikswap Protocol.\"), mdx(\"p\", null, \"Kwikswap protocol is a decentralized trading platform. Kwikswap does not use an order book to represent liquidity or determine prices. Kwikswap uses an automated market maker mechanism to provide instant feedback on rates and slippage.\"), mdx(\"p\", null, \"In this guide, we\\u2019ll look at what happens during a swap at the Kwikswap protocol level to gain a deeper understanding of how Kwikswap works.\"), mdx(\"p\", null, \"This rule is the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/docs/v1/protocol-overview/glossary#constant-product-formula\"\n  }, \"constant product formula\"), \". When either token is withdrawn (purchased), a proportional amount of the other must be deposited (sold), to maintain the constant.\"), mdx(\"p\", null, \"As we learned in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/docs/v1/protocol-overview/how-kwikswap-works\"\n  }, \"Protocol Overview\"), \", each pair on Kwikswap is actually underpinned by a liquidity pool. Smart contracts are used to maintain the Liquidity Pools of different Tokens.\"), mdx(\"h2\", {\n    \"id\": \"anatomy-of-a-swap\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#anatomy-of-a-swap\",\n    \"aria-label\": \"anatomy of a swap permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Anatomy of a swap\"), mdx(\"p\", null, \"In Kwikswap, all the Swaps are get done by calling the single function of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"swap\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data);\\n\")), mdx(\"h1\", {\n    \"id\": \"receiving-tokens\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#receiving-tokens\",\n    \"aria-label\": \"receiving tokens permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Receiving tokens\"), mdx(\"p\", null, \"As is probably clear from the function signature, Kwikswap requires \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"swap\"), \" callers to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"specify how many output tokens they would like to receive\"), \" via the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"amount{0,1}Out\"), \" parameters, which correspond to the desired amount of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"token{0,1}\"), \".\"), mdx(\"h1\", {\n    \"id\": \"sending-tokens\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#sending-tokens\",\n    \"aria-label\": \"sending tokens permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Sending Tokens\"), mdx(\"p\", null, \"What\\u2019s not as clear is how Kwikswap \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"receives\"), \" tokens as payment for the swap. Typically, smart contracts which need tokens to perform some functionality require callers to first make an approval on the token contract, then call a function that in turn calls transferFrom on the token contract. This is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" how pairs accept tokens. Instead, pairs check their token balances at the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"end\"), \" of every interaction. Then, at the beginning of the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"next\"), \" interaction, current balances are differenced against the stored values to determine the amount of tokens that were sent by the current interactor. See the \", mdx(\"a\", {\n    href: \"/whitepaper.pdf\",\n    rel: \"noopener noreferrer\"\n  }, \"whitepaper\"), \" for a justification of why this is the case.\"), mdx(\"h1\", {\n    \"id\": \"developer-resources\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#developer-resources\",\n    \"aria-label\": \"developer resources permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Developer resources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"To see how to implement token swaps in a smart contract read \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/docs/v1/smart-contract-integration/trading-from-a-smart-contract/\"\n  }, \"Trading from a smart contract\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"To see how to execute a swap from an interface read \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/docs/v1/javascript-SDK/trading/\"\n  }, \"Trading (SDK)\"))));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"Swaps\",\n  \"subtitle\": \"Learn about the core functionality of the kwikswap protocol. Token Swaps.\",\n  \"tags\": \"swaps, documentation\"\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1 {...{\n      \"id\": \"introduction\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h1\" {...{\n        \"href\": \"#introduction\",\n        \"aria-label\": \"introduction permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Introduction`}</h1>\n    <p>{`Swapping is a kind of process in which, A user picks an input token and get an output token. They specify an input amount, and the Kwikswap protocol automatically calculates how much of the output tokens user will receive. They then execute the swap by clicking the “Swap” button, and immediately user receives the output token in the wallet.`}</p>\n    <p>{`Swapping the ERC-20 Token is quite easy in Kwikswap Protocol.`}</p>\n    <p>{`Kwikswap protocol is a decentralized trading platform. Kwikswap does not use an order book to represent liquidity or determine prices. Kwikswap uses an automated market maker mechanism to provide instant feedback on rates and slippage.`}</p>\n    <p>{`In this guide, we’ll look at what happens during a swap at the Kwikswap protocol level to gain a deeper understanding of how Kwikswap works.`}</p>\n    <p>{`This rule is the `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/v1/protocol-overview/glossary#constant-product-formula\"\n      }}>{`constant product formula`}</a>{`. When either token is withdrawn (purchased), a proportional amount of the other must be deposited (sold), to maintain the constant.`}</p>\n    <p>{`As we learned in `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/v1/protocol-overview/how-kwikswap-works\"\n      }}>{`Protocol Overview`}</a>{`, each pair on Kwikswap is actually underpinned by a liquidity pool. Smart contracts are used to maintain the Liquidity Pools of different Tokens.`}</p>\n    <h2 {...{\n      \"id\": \"anatomy-of-a-swap\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h2\" {...{\n        \"href\": \"#anatomy-of-a-swap\",\n        \"aria-label\": \"anatomy of a swap permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Anatomy of a swap`}</h2>\n    <p>{`In Kwikswap, all the Swaps are get done by calling the single function of `}<inlineCode parentName=\"p\">{`swap`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-solidity\"\n      }}>{`function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data);\n`}</code></pre>\n    <h1 {...{\n      \"id\": \"receiving-tokens\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h1\" {...{\n        \"href\": \"#receiving-tokens\",\n        \"aria-label\": \"receiving tokens permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Receiving tokens`}</h1>\n    <p>{`As is probably clear from the function signature, Kwikswap requires `}<inlineCode parentName=\"p\">{`swap`}</inlineCode>{` callers to `}<em parentName=\"p\">{`specify how many output tokens they would like to receive`}</em>{` via the `}<inlineCode parentName=\"p\">{`amount{0,1}Out`}</inlineCode>{` parameters, which correspond to the desired amount of `}<inlineCode parentName=\"p\">{`token{0,1}`}</inlineCode>{`.`}</p>\n    <h1 {...{\n      \"id\": \"sending-tokens\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h1\" {...{\n        \"href\": \"#sending-tokens\",\n        \"aria-label\": \"sending tokens permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Sending Tokens`}</h1>\n    <p>{`What’s not as clear is how Kwikswap `}<em parentName=\"p\">{`receives`}</em>{` tokens as payment for the swap. Typically, smart contracts which need tokens to perform some functionality require callers to first make an approval on the token contract, then call a function that in turn calls transferFrom on the token contract. This is `}<em parentName=\"p\">{`not`}</em>{` how pairs accept tokens. Instead, pairs check their token balances at the `}<em parentName=\"p\">{`end`}</em>{` of every interaction. Then, at the beginning of the `}<em parentName=\"p\">{`next`}</em>{` interaction, current balances are differenced against the stored values to determine the amount of tokens that were sent by the current interactor. See the `}<a href='/whitepaper.pdf' rel='noopener noreferrer'>{`whitepaper`}</a>{` for a justification of why this is the case.`}</p>\n    <h1 {...{\n      \"id\": \"developer-resources\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h1\" {...{\n        \"href\": \"#developer-resources\",\n        \"aria-label\": \"developer resources permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Developer resources`}</h1>\n    <ul>\n      <li parentName=\"ul\">{`To see how to implement token swaps in a smart contract read `}<a parentName=\"li\" {...{\n          \"href\": \"/docs/v1/smart-contract-integration/trading-from-a-smart-contract/\"\n        }}>{`Trading from a smart contract`}</a>{`.`}</li>\n      <li parentName=\"ul\">{`To see how to execute a swap from an interface read `}<a parentName=\"li\" {...{\n          \"href\": \"/docs/v1/javascript-SDK/trading/\"\n        }}>{`Trading (SDK)`}</a></li>\n    </ul>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}