{"expireTime":9007200872306493000,"key":"gatsby-plugin-mdx-entire-payload-eb6c6d7670980ecf65a7b9f98d4a3802-","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"Looking for a ","position":{"start":{"line":2,"column":1,"offset":2},"end":{"line":2,"column":15,"offset":16},"indent":[]}},{"type":"jsx","value":"<Link to='/docs/v1/javascript-SDK/quick-start'>","position":{"start":{"line":2,"column":15,"offset":16},"end":{"line":2,"column":62,"offset":63},"indent":[]}},{"type":"text","value":"quickstart","position":{"start":{"line":2,"column":62,"offset":63},"end":{"line":2,"column":72,"offset":73},"indent":[]}},{"type":"jsx","value":"</Link>","position":{"start":{"line":2,"column":72,"offset":73},"end":{"line":2,"column":79,"offset":80},"indent":[]}},{"type":"text","value":"?","position":{"start":{"line":2,"column":79,"offset":80},"end":{"line":2,"column":80,"offset":81},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":2},"end":{"line":2,"column":80,"offset":81},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The SDK ","position":{"start":{"line":4,"column":1,"offset":85},"end":{"line":4,"column":9,"offset":93},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"cannot execute trades or send transactions on your behalf","position":{"start":{"line":4,"column":10,"offset":94},"end":{"line":4,"column":67,"offset":151},"indent":[]}}],"position":{"start":{"line":4,"column":9,"offset":93},"end":{"line":4,"column":68,"offset":152},"indent":[]}},{"type":"text","value":". Rather, it offers utility classes and functions which make it easy to calculate the data required to safely interact with Kwikswap. Nearly everything you need to safely transact with Kwikswap is provided by the ","position":{"start":{"line":4,"column":68,"offset":152},"end":{"line":4,"column":281,"offset":365},"indent":[]}},{"type":"jsx","value":"<Link to='/docs/v1/SDK/trade'>","position":{"start":{"line":4,"column":281,"offset":365},"end":{"line":4,"column":311,"offset":395},"indent":[]}},{"type":"text","value":"Trade","position":{"start":{"line":4,"column":311,"offset":395},"end":{"line":4,"column":316,"offset":400},"indent":[]}},{"type":"jsx","value":"</Link>","position":{"start":{"line":4,"column":316,"offset":400},"end":{"line":4,"column":323,"offset":407},"indent":[]}},{"type":"text","value":" entity. However, it is your responsibility to use this data to send transactions in whatever context makes sense for your application.","position":{"start":{"line":4,"column":323,"offset":407},"end":{"line":4,"column":458,"offset":542},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":85},"end":{"line":4,"column":458,"offset":542},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This guide will focus exclusively on sending a transaction to the ","position":{"start":{"line":6,"column":1,"offset":546},"end":{"line":6,"column":67,"offset":612},"indent":[]}},{"type":"jsx","value":"<Link to='/docs/v1/smart-contracts/router02'>","position":{"start":{"line":6,"column":67,"offset":612},"end":{"line":6,"column":112,"offset":657},"indent":[]}},{"type":"text","value":"currently recommended Kwikswap router","position":{"start":{"line":6,"column":112,"offset":657},"end":{"line":6,"column":149,"offset":694},"indent":[]}},{"type":"jsx","value":"</Link>","position":{"start":{"line":6,"column":149,"offset":694},"end":{"line":6,"column":156,"offset":701},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":6,"column":156,"offset":701},"end":{"line":6,"column":157,"offset":702},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":546},"end":{"line":6,"column":157,"offset":702},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Sending a Transaction to the Router","position":{"start":{"line":8,"column":3,"offset":708},"end":{"line":8,"column":38,"offset":743},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":706},"end":{"line":8,"column":38,"offset":743},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Let's say we want to trade 1 WETH for as much DAI as possible:","position":{"start":{"line":10,"column":1,"offset":747},"end":{"line":10,"column":63,"offset":809},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":747},"end":{"line":10,"column":63,"offset":809},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"import { ChainId, Token, WETH, Fetcher, Trade, Route, TokenAmount, TradeType } from '@kwikswap/sdk'\n\nconst DAI = new Token(ChainId.MAINNET, '0x6B175474E89094C44Da98b954EedeAC495271d0F', 18)\n\n// note that you may want/need to handle this async code differently,\n// for example if top-level await is not an option\nconst pair = await Fetcher.fetchPairData(DAI, WETH[DAI.chainId])\n\nconst route = new Route([pair], WETH[DAI.chainId])\n\nconst amountIn = '1000000000000000000' // 1 WETH\n\nconst trade = new Trade(route, new TokenAmount(WETH[DAI.chainId], amountIn), TradeType.EXACT_INPUT)","position":{"start":{"line":12,"column":1,"offset":813},"end":{"line":26,"column":4,"offset":1424},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"So, we've constructed a trade entity, but how do we use it to actually send a transaction? There are still a few pieces we need to put in place.","position":{"start":{"line":28,"column":1,"offset":1428},"end":{"line":28,"column":145,"offset":1572},"indent":[]}}],"position":{"start":{"line":28,"column":1,"offset":1428},"end":{"line":28,"column":145,"offset":1572},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Before going on, we should explore how ETH works in the context of trading. Internally, the SDK uses WETH, as all Kwikswap pairs use WETH under the hood. However, it's perfectly possible for you as an end user to use ETH, and rely on the router to handle converting to/from WETH. So, let's use ETH.","position":{"start":{"line":30,"column":1,"offset":1576},"end":{"line":30,"column":299,"offset":1874},"indent":[]}}],"position":{"start":{"line":30,"column":1,"offset":1576},"end":{"line":30,"column":299,"offset":1874},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The first step is selecting the appropriate router function. The names of router functions are intended to be self-explanatory; in this case we want ","position":{"start":{"line":32,"column":1,"offset":1878},"end":{"line":32,"column":150,"offset":2027},"indent":[]}},{"type":"jsx","value":"<Link to='/docs/v1/smart-contracts/router02/#swapexactethfortokens'>","position":{"start":{"line":32,"column":150,"offset":2027},"end":{"line":32,"column":218,"offset":2095},"indent":[]}},{"type":"text","value":"swapExactETHForTokens","position":{"start":{"line":32,"column":218,"offset":2095},"end":{"line":32,"column":239,"offset":2116},"indent":[]}},{"type":"jsx","value":"</Link>","position":{"start":{"line":32,"column":239,"offset":2116},"end":{"line":32,"column":246,"offset":2123},"indent":[]}},{"type":"text","value":", because we're...swapping an exact amount of ETH for tokens.","position":{"start":{"line":32,"column":246,"offset":2123},"end":{"line":32,"column":307,"offset":2184},"indent":[]}}],"position":{"start":{"line":32,"column":1,"offset":1878},"end":{"line":32,"column":307,"offset":2184},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"That Solidity interface for this function is:","position":{"start":{"line":34,"column":1,"offset":2188},"end":{"line":34,"column":46,"offset":2233},"indent":[]}}],"position":{"start":{"line":34,"column":1,"offset":2188},"end":{"line":34,"column":46,"offset":2233},"indent":[]}},{"type":"code","lang":"solidity","meta":null,"value":"function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n  external\n  payable\n  returns (uint[] memory amounts);","position":{"start":{"line":36,"column":1,"offset":2237},"end":{"line":41,"column":4,"offset":2415},"indent":[1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Jumping back to our trading code, we can construct all the necessary parameters:","position":{"start":{"line":43,"column":1,"offset":2419},"end":{"line":43,"column":81,"offset":2499},"indent":[]}}],"position":{"start":{"line":43,"column":1,"offset":2419},"end":{"line":43,"column":81,"offset":2499},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"import { Percent } from '@kwikswap/sdk'\n\nconst slippageTolerance = new Percent('50', '10000') // 50 bips, or 0.50%\n\nconst amountOutMin = trade.minimumAmountOut(slippageTolerance).raw // needs to be converted to e.g. hex\nconst path = [WETH[DAI.chainId].address, DAI.address]\nconst to = '' // should be a checksummed recipient address\nconst deadline = Math.floor(Date.now() / 1000) + 60 * 20 // 20 minutes from the current Unix time\nconst value = trade.inputAmount.raw // // needs to be converted to e.g. hex","position":{"start":{"line":45,"column":1,"offset":2503},"end":{"line":55,"column":4,"offset":3037},"indent":[1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The slippage tolerance encodes ","position":{"start":{"line":57,"column":1,"offset":3041},"end":{"line":57,"column":32,"offset":3072},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"how large of a price movement we're willing to tolerate before our trade will fail to execute","position":{"start":{"line":57,"column":33,"offset":3073},"end":{"line":57,"column":126,"offset":3166},"indent":[]}}],"position":{"start":{"line":57,"column":32,"offset":3072},"end":{"line":57,"column":127,"offset":3167},"indent":[]}},{"type":"text","value":". Since Ethereum transactions are broadcast and confirmed in an adversarial environment, this tolerance is the best we can do to protect ourselves against price movements. We use this slippage tolerance to calculate the ","position":{"start":{"line":57,"column":127,"offset":3167},"end":{"line":57,"column":347,"offset":3387},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"minumum","position":{"start":{"line":57,"column":348,"offset":3388},"end":{"line":57,"column":355,"offset":3395},"indent":[]}}],"position":{"start":{"line":57,"column":347,"offset":3387},"end":{"line":57,"column":356,"offset":3396},"indent":[]}},{"type":"text","value":" amount of DAI we must receive before our trade reverts, thanks to ","position":{"start":{"line":57,"column":356,"offset":3396},"end":{"line":57,"column":423,"offset":3463},"indent":[]}},{"type":"jsx","value":"<Link to='/docs/v1/SDK/trade/#minimumamountout-since-204'>","position":{"start":{"line":57,"column":423,"offset":3463},"end":{"line":57,"column":481,"offset":3521},"indent":[]}},{"type":"text","value":"minimumAmountOut","position":{"start":{"line":57,"column":481,"offset":3521},"end":{"line":57,"column":497,"offset":3537},"indent":[]}},{"type":"jsx","value":"</Link>","position":{"start":{"line":57,"column":497,"offset":3537},"end":{"line":57,"column":504,"offset":3544},"indent":[]}},{"type":"text","value":". Note that this code calculates this worst-case outcome ","position":{"start":{"line":57,"column":504,"offset":3544},"end":{"line":57,"column":561,"offset":3601},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"assuming that the current price, i.e the route's mid price,","position":{"start":{"line":57,"column":562,"offset":3602},"end":{"line":57,"column":621,"offset":3661},"indent":[]}}],"position":{"start":{"line":57,"column":561,"offset":3601},"end":{"line":57,"column":622,"offset":3662},"indent":[]}},{"type":"text","value":" is fair (usually a good assumption because of arbitrage).","position":{"start":{"line":57,"column":622,"offset":3662},"end":{"line":57,"column":680,"offset":3720},"indent":[]}}],"position":{"start":{"line":57,"column":1,"offset":3041},"end":{"line":57,"column":680,"offset":3720},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The path is simply the ordered list of token addresses we're trading through, in our case WETH and DAI (note that we use the WETH address, even though we're using ETH). ","position":{"start":{"line":59,"column":1,"offset":3724},"end":{"line":59,"column":170,"offset":3893},"indent":[]}}],"position":{"start":{"line":59,"column":1,"offset":3724},"end":{"line":59,"column":170,"offset":3893},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The to address is the address that will receive the DAI.","position":{"start":{"line":61,"column":1,"offset":3897},"end":{"line":61,"column":57,"offset":3953},"indent":[]}}],"position":{"start":{"line":61,"column":1,"offset":3897},"end":{"line":61,"column":57,"offset":3953},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The deadline is the Unix timestamp after which the transaction will fail, to protect us in the case that our transaction takes a long time to confirm and we wish to rescind our trade.","position":{"start":{"line":63,"column":1,"offset":3957},"end":{"line":63,"column":184,"offset":4140},"indent":[]}}],"position":{"start":{"line":63,"column":1,"offset":3957},"end":{"line":63,"column":184,"offset":4140},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The value is the amount of ETH that must be included as the ","position":{"start":{"line":65,"column":1,"offset":4144},"end":{"line":65,"column":61,"offset":4204},"indent":[]}},{"type":"inlineCode","value":"msg.value","position":{"start":{"line":65,"column":61,"offset":4204},"end":{"line":65,"column":72,"offset":4215},"indent":[]}},{"type":"text","value":" in our transaction.","position":{"start":{"line":65,"column":72,"offset":4215},"end":{"line":65,"column":92,"offset":4235},"indent":[]}}],"position":{"start":{"line":65,"column":1,"offset":4144},"end":{"line":65,"column":92,"offset":4235},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"Trading\",\"tags\":\"SDK, developer-guides, documentation\"}","position":{"start":{"line":68,"column":1,"offset":4239},"end":{"line":68,"column":94,"offset":4332},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":68,"column":94,"offset":4332}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Trading\",\n  \"tags\": \"SDK, developer-guides, documentation\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Link = makeShortcode(\"Link\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Looking for a \", mdx(Link, {\n    to: \"/docs/v1/javascript-SDK/quick-start\",\n    mdxType: \"Link\"\n  }, \"quickstart\"), \"?\"), mdx(\"p\", null, \"The SDK \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cannot execute trades or send transactions on your behalf\"), \". Rather, it offers utility classes and functions which make it easy to calculate the data required to safely interact with Kwikswap. Nearly everything you need to safely transact with Kwikswap is provided by the \", mdx(Link, {\n    to: \"/docs/v1/SDK/trade\",\n    mdxType: \"Link\"\n  }, \"Trade\"), \" entity. However, it is your responsibility to use this data to send transactions in whatever context makes sense for your application.\"), mdx(\"p\", null, \"This guide will focus exclusively on sending a transaction to the \", mdx(Link, {\n    to: \"/docs/v1/smart-contracts/router02\",\n    mdxType: \"Link\"\n  }, \"currently recommended Kwikswap router\"), \".\"), mdx(\"h1\", {\n    \"id\": \"sending-a-transaction-to-the-router\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#sending-a-transaction-to-the-router\",\n    \"aria-label\": \"sending a transaction to the router permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Sending a Transaction to the Router\"), mdx(\"p\", null, \"Let\\u2019s say we want to trade 1 WETH for as much DAI as possible:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"import { ChainId, Token, WETH, Fetcher, Trade, Route, TokenAmount, TradeType } from '@kwikswap/sdk'\\n\\nconst DAI = new Token(ChainId.MAINNET, '0x6B175474E89094C44Da98b954EedeAC495271d0F', 18)\\n\\n// note that you may want/need to handle this async code differently,\\n// for example if top-level await is not an option\\nconst pair = await Fetcher.fetchPairData(DAI, WETH[DAI.chainId])\\n\\nconst route = new Route([pair], WETH[DAI.chainId])\\n\\nconst amountIn = '1000000000000000000' // 1 WETH\\n\\nconst trade = new Trade(route, new TokenAmount(WETH[DAI.chainId], amountIn), TradeType.EXACT_INPUT)\\n\")), mdx(\"p\", null, \"So, we\\u2019ve constructed a trade entity, but how do we use it to actually send a transaction? There are still a few pieces we need to put in place.\"), mdx(\"p\", null, \"Before going on, we should explore how ETH works in the context of trading. Internally, the SDK uses WETH, as all Kwikswap pairs use WETH under the hood. However, it\\u2019s perfectly possible for you as an end user to use ETH, and rely on the router to handle converting to/from WETH. So, let\\u2019s use ETH.\"), mdx(\"p\", null, \"The first step is selecting the appropriate router function. The names of router functions are intended to be self-explanatory; in this case we want \", mdx(Link, {\n    to: \"/docs/v1/smart-contracts/router02/#swapexactethfortokens\",\n    mdxType: \"Link\"\n  }, \"swapExactETHForTokens\"), \", because we\\u2019re\\u2026swapping an exact amount of ETH for tokens.\"), mdx(\"p\", null, \"That Solidity interface for this function is:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n  external\\n  payable\\n  returns (uint[] memory amounts);\\n\")), mdx(\"p\", null, \"Jumping back to our trading code, we can construct all the necessary parameters:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"import { Percent } from '@kwikswap/sdk'\\n\\nconst slippageTolerance = new Percent('50', '10000') // 50 bips, or 0.50%\\n\\nconst amountOutMin = trade.minimumAmountOut(slippageTolerance).raw // needs to be converted to e.g. hex\\nconst path = [WETH[DAI.chainId].address, DAI.address]\\nconst to = '' // should be a checksummed recipient address\\nconst deadline = Math.floor(Date.now() / 1000) + 60 * 20 // 20 minutes from the current Unix time\\nconst value = trade.inputAmount.raw // // needs to be converted to e.g. hex\\n\")), mdx(\"p\", null, \"The slippage tolerance encodes \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"how large of a price movement we\\u2019re willing to tolerate before our trade will fail to execute\"), \". Since Ethereum transactions are broadcast and confirmed in an adversarial environment, this tolerance is the best we can do to protect ourselves against price movements. We use this slippage tolerance to calculate the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"minumum\"), \" amount of DAI we must receive before our trade reverts, thanks to \", mdx(Link, {\n    to: \"/docs/v1/SDK/trade/#minimumamountout-since-204\",\n    mdxType: \"Link\"\n  }, \"minimumAmountOut\"), \". Note that this code calculates this worst-case outcome \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"assuming that the current price, i.e the route\\u2019s mid price,\"), \" is fair (usually a good assumption because of arbitrage).\"), mdx(\"p\", null, \"The path is simply the ordered list of token addresses we\\u2019re trading through, in our case WETH and DAI (note that we use the WETH address, even though we\\u2019re using ETH). \"), mdx(\"p\", null, \"The to address is the address that will receive the DAI.\"), mdx(\"p\", null, \"The deadline is the Unix timestamp after which the transaction will fail, to protect us in the case that our transaction takes a long time to confirm and we wish to rescind our trade.\"), mdx(\"p\", null, \"The value is the amount of ETH that must be included as the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"msg.value\"), \" in our transaction.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"Trading\",\n  \"tags\": \"SDK, developer-guides, documentation\"\n};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n      console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n      return <div {...props}/>\n    };\nconst Link = makeShortcode(\"Link\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`Looking for a `}<Link to='/docs/v1/javascript-SDK/quick-start' mdxType=\"Link\">{`quickstart`}</Link>{`?`}</p>\n    <p>{`The SDK `}<em parentName=\"p\">{`cannot execute trades or send transactions on your behalf`}</em>{`. Rather, it offers utility classes and functions which make it easy to calculate the data required to safely interact with Kwikswap. Nearly everything you need to safely transact with Kwikswap is provided by the `}<Link to='/docs/v1/SDK/trade' mdxType=\"Link\">{`Trade`}</Link>{` entity. However, it is your responsibility to use this data to send transactions in whatever context makes sense for your application.`}</p>\n    <p>{`This guide will focus exclusively on sending a transaction to the `}<Link to='/docs/v1/smart-contracts/router02' mdxType=\"Link\">{`currently recommended Kwikswap router`}</Link>{`.`}</p>\n    <h1 {...{\n      \"id\": \"sending-a-transaction-to-the-router\",\n      \"style\": {\n        \"position\": \"relative\"\n      }\n    }}><a parentName=\"h1\" {...{\n        \"href\": \"#sending-a-transaction-to-the-router\",\n        \"aria-label\": \"sending a transaction to the router permalink\",\n        \"className\": \"anchor before\"\n      }}><svg parentName=\"a\" {...{\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }}><path parentName=\"svg\" {...{\n            \"fillRule\": \"evenodd\",\n            \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n          }}></path></svg></a>{`Sending a Transaction to the Router`}</h1>\n    <p>{`Let’s say we want to trade 1 WETH for as much DAI as possible:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { ChainId, Token, WETH, Fetcher, Trade, Route, TokenAmount, TradeType } from '@kwikswap/sdk'\n\nconst DAI = new Token(ChainId.MAINNET, '0x6B175474E89094C44Da98b954EedeAC495271d0F', 18)\n\n// note that you may want/need to handle this async code differently,\n// for example if top-level await is not an option\nconst pair = await Fetcher.fetchPairData(DAI, WETH[DAI.chainId])\n\nconst route = new Route([pair], WETH[DAI.chainId])\n\nconst amountIn = '1000000000000000000' // 1 WETH\n\nconst trade = new Trade(route, new TokenAmount(WETH[DAI.chainId], amountIn), TradeType.EXACT_INPUT)\n`}</code></pre>\n    <p>{`So, we’ve constructed a trade entity, but how do we use it to actually send a transaction? There are still a few pieces we need to put in place.`}</p>\n    <p>{`Before going on, we should explore how ETH works in the context of trading. Internally, the SDK uses WETH, as all Kwikswap pairs use WETH under the hood. However, it’s perfectly possible for you as an end user to use ETH, and rely on the router to handle converting to/from WETH. So, let’s use ETH.`}</p>\n    <p>{`The first step is selecting the appropriate router function. The names of router functions are intended to be self-explanatory; in this case we want `}<Link to='/docs/v1/smart-contracts/router02/#swapexactethfortokens' mdxType=\"Link\">{`swapExactETHForTokens`}</Link>{`, because we’re…swapping an exact amount of ETH for tokens.`}</p>\n    <p>{`That Solidity interface for this function is:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-solidity\"\n      }}>{`function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n  external\n  payable\n  returns (uint[] memory amounts);\n`}</code></pre>\n    <p>{`Jumping back to our trading code, we can construct all the necessary parameters:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { Percent } from '@kwikswap/sdk'\n\nconst slippageTolerance = new Percent('50', '10000') // 50 bips, or 0.50%\n\nconst amountOutMin = trade.minimumAmountOut(slippageTolerance).raw // needs to be converted to e.g. hex\nconst path = [WETH[DAI.chainId].address, DAI.address]\nconst to = '' // should be a checksummed recipient address\nconst deadline = Math.floor(Date.now() / 1000) + 60 * 20 // 20 minutes from the current Unix time\nconst value = trade.inputAmount.raw // // needs to be converted to e.g. hex\n`}</code></pre>\n    <p>{`The slippage tolerance encodes `}<em parentName=\"p\">{`how large of a price movement we’re willing to tolerate before our trade will fail to execute`}</em>{`. Since Ethereum transactions are broadcast and confirmed in an adversarial environment, this tolerance is the best we can do to protect ourselves against price movements. We use this slippage tolerance to calculate the `}<em parentName=\"p\">{`minumum`}</em>{` amount of DAI we must receive before our trade reverts, thanks to `}<Link to='/docs/v1/SDK/trade/#minimumamountout-since-204' mdxType=\"Link\">{`minimumAmountOut`}</Link>{`. Note that this code calculates this worst-case outcome `}<em parentName=\"p\">{`assuming that the current price, i.e the route’s mid price,`}</em>{` is fair (usually a good assumption because of arbitrage).`}</p>\n    <p>{`The path is simply the ordered list of token addresses we’re trading through, in our case WETH and DAI (note that we use the WETH address, even though we’re using ETH). `}</p>\n    <p>{`The to address is the address that will receive the DAI.`}</p>\n    <p>{`The deadline is the Unix timestamp after which the transaction will fail, to protect us in the case that our transaction takes a long time to confirm and we wish to rescind our trade.`}</p>\n    <p>{`The value is the amount of ETH that must be included as the `}<inlineCode parentName=\"p\">{`msg.value`}</inlineCode>{` in our transaction.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}